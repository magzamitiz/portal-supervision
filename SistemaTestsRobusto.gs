/**
 * SistemaTestsRobusto.gs
 * Sistema consolidado de pruebas robustas para el Portal de Supervisi√≥n
 * Reemplaza m√∫ltiples archivos de test con un sistema unificado y eficiente
 */

/**
 * Configuraci√≥n centralizada de pruebas
 */
const TEST_CONFIG = {
  // Configuraci√≥n de rendimiento
  PERFORMANCE: {
    TIMEOUT_LIMITS: {
      EXCELLENT: 1000,    // < 1s
      GOOD: 3000,         // < 3s
      ACCEPTABLE: 5000,   // < 5s
      SLOW: 10000,        // < 10s
      CRITICAL: 15000     // < 15s
    },
    BATCH_SIZES: [5, 10, 15, 20, 25, 30],
    ITEM_COUNTS: [10, 25, 50, 100]
  },
  
  // Configuraci√≥n de datos de prueba
  DATA: {
    LCF_SAMPLE_SIZE: 3,
    LD_SAMPLE_SIZE: 2,
    CACHE_TTL: 300
  },
  
  // Configuraci√≥n general
  GENERAL: {
    MAX_RETRIES: 3,
    RETRY_DELAY: 1000,
    LOG_LEVEL: 'INFO' // DEBUG, INFO, WARN, ERROR
  }
};

/**
 * Clase principal para manejo de pruebas
 */
class TestManager {
  constructor() {
    this.resultados = {
      inicio: new Date().toISOString(),
      pruebas: [],
      exitoso: true,
      tiempoTotal: 0,
      estadisticas: {
        total: 0,
        exitosas: 0,
        fallidas: 0,
        errores: 0
      }
    };
  }
  
  /**
   * Ejecuta una prueba individual
   */
  async ejecutarPrueba(nombre, funcion, categoria = 'general') {
    const inicio = Date.now();
    console.log(`\nüß™ [${categoria.toUpperCase()}] ${nombre}`);
    console.log('-'.repeat(50));
    
    try {
      const resultado = await funcion();
      const duracion = Date.now() - inicio;
      
      const prueba = {
        nombre,
        categoria,
        exitosa: resultado.success || false,
        duracion,
        detalles: resultado.details || resultado,
        timestamp: new Date().toISOString()
      };
      
      this.resultados.pruebas.push(prueba);
      this.resultados.estadisticas.total++;
      
      if (prueba.exitosa) {
        this.resultados.estadisticas.exitosas++;
        console.log(`‚úÖ ${nombre} - ${duracion}ms`);
      } else {
        this.resultados.estadisticas.fallidas++;
        console.log(`‚ùå ${nombre} - ${duracion}ms`);
        console.log(`   Error: ${resultado.error || 'Prueba fall√≥'}`);
      }
      
      return prueba;
      
    } catch (error) {
      const duracion = Date.now() - inicio;
      this.resultados.estadisticas.errores++;
      
      const prueba = {
        nombre,
        categoria,
        exitosa: false,
        duracion,
        error: error.toString(),
        timestamp: new Date().toISOString()
      };
      
      this.resultados.pruebas.push(prueba);
      console.log(`üí• ${nombre} - ERROR: ${error.toString()}`);
      
      return prueba;
    }
  }
  
  /**
   * Genera resumen final
   */
  generarResumen() {
    this.resultados.tiempoTotal = Date.now() - new Date(this.resultados.inicio).getTime();
    this.resultados.exitoso = this.resultados.estadisticas.errores === 0 && 
                              this.resultados.estadisticas.fallidas === 0;
    
    console.log('\n' + '='.repeat(60));
    console.log('üìä RESUMEN FINAL DE PRUEBAS');
    console.log('='.repeat(60));
    console.log(`‚è±Ô∏è  Tiempo total: ${this.resultados.tiempoTotal}ms`);
    console.log(`üìà Total de pruebas: ${this.resultados.estadisticas.total}`);
    console.log(`‚úÖ Exitosas: ${this.resultados.estadisticas.exitosas}`);
    console.log(`‚ùå Fallidas: ${this.resultados.estadisticas.fallidas}`);
    console.log(`üí• Errores: ${this.resultados.estadisticas.errores}`);
    console.log(`üìä Tasa de √©xito: ${((this.resultados.estadisticas.exitosas / this.resultados.estadisticas.total) * 100).toFixed(1)}%`);
    
    if (this.resultados.exitoso) {
      console.log('\nüéâ TODAS LAS PRUEBAS EXITOSAS');
    } else {
      console.log('\n‚ö†Ô∏è ALGUNAS PRUEBAS FALLARON');
    }
    
    return this.resultados;
  }
}

/**
 * Pruebas de funcionalidad b√°sica
 */
class PruebasFuncionalidad {
  /**
   * Prueba getDashboardData
   */
  static async probarDashboardData() {
    try {
      const startTime = Date.now();
      const dashboard = getDashboardData();
      const duracion = Date.now() - startTime;
      
      const exito = dashboard.success && 
                   dashboard.data && 
                   dashboard.data.actividad &&
                   dashboard.data.metricas;
      
      return {
        success: exito,
        details: {
          duracion,
          tieneActividad: !!dashboard.data?.actividad,
          tieneMetricas: !!dashboard.data?.metricas,
          modoCarga: dashboard.data?.modo_carga || 'N/A'
        }
      };
    } catch (error) {
      return { success: false, error: error.toString() };
    }
  }
  
  /**
   * Prueba getEstadisticasRapidas
   */
  static async probarEstadisticasRapidas() {
    try {
      const startTime = Date.now();
      const stats = getEstadisticasRapidas();
      const duracion = Date.now() - startTime;
      
      const exito = stats.success && 
                   stats.data && 
                   stats.data.actividad &&
                   stats.data.metricas;
      
      return {
        success: exito,
        details: {
          duracion,
          tieneActividad: !!stats.data?.actividad,
          tieneMetricas: !!stats.data?.metricas,
          totalLideres: stats.data?.metricas?.total_lideres || 0
        }
      };
    } catch (error) {
      return { success: false, error: error.toString() };
    }
  }
  
  /**
   * Prueba getListaDeLideres
   */
  static async probarListaDeLideres() {
    try {
      const startTime = Date.now();
      const lideres = getListaDeLideres();
      const duracion = Date.now() - startTime;
      
      const exito = lideres.success && 
                   lideres.data && 
                   Array.isArray(lideres.data) &&
                   lideres.data.length > 0;
      
      return {
        success: exito,
        details: {
          duracion,
          totalLideres: lideres.data?.length || 0,
          estructuraCorrecta: lideres.data?.[0]?.ID_Lider ? true : false
        }
      };
    } catch (error) {
      return { success: false, error: error.toString() };
    }
  }
  
  /**
   * Prueba de modales
   */
  static async probarModales() {
    try {
      // Obtener un LCF v√°lido
      const lcfId = obtenerLCFValidoParaPruebas();
      if (!lcfId) {
        return { success: false, error: 'No hay LCFs disponibles para prueba' };
      }
      
      // Probar getResumenLCF
      const resumen = getResumenLCF(lcfId);
      const resumenOk = resumen.success && resumen.data;
      
      // Probar cargarDatosLCF
      const datos = cargarDatosLCF(lcfId);
      const datosOk = datos.success && datos.celulas && datos.almas;
      
      return {
        success: resumenOk && datosOk,
        details: {
          lcfId,
          resumenOk,
          datosOk,
          totalCelulas: datos.celulas?.length || 0,
          totalAlmas: datos.almas?.length || 0
        }
      };
    } catch (error) {
      return { success: false, error: error.toString() };
    }
  }
}

/**
 * Pruebas de rendimiento
 */
class PruebasRendimiento {
  /**
   * Prueba de rendimiento general
   */
  static async probarRendimientoGeneral() {
    try {
      const pruebas = [
        { nombre: 'Dashboard', funcion: getDashboardData },
        { nombre: 'Estad√≠sticas', funcion: getEstadisticasRapidas },
        { nombre: 'L√≠deres', funcion: getListaDeLideres }
      ];
      
      const resultados = [];
      
      for (const prueba of pruebas) {
        const startTime = Date.now();
        const resultado = prueba.funcion();
        const duracion = Date.now() - startTime;
        
        resultados.push({
          nombre: prueba.nombre,
          duracion,
          exitosa: resultado.success || false,
          categoria: this.categorizarRendimiento(duracion)
        });
      }
      
      const promedio = resultados.reduce((sum, r) => sum + r.duracion, 0) / resultados.length;
      const maximo = Math.max(...resultados.map(r => r.duracion));
      
      return {
        success: true,
        details: {
          resultados,
          promedio,
          maximo,
          categoriaGeneral: this.categorizarRendimiento(promedio)
        }
      };
    } catch (error) {
      return { success: false, error: error.toString() };
    }
  }
  
  /**
   * Categoriza el rendimiento basado en duraci√≥n
   */
  static categorizarRendimiento(duracion) {
    if (duracion < TEST_CONFIG.PERFORMANCE.TIMEOUT_LIMITS.EXCELLENT) return 'EXCELENTE';
    if (duracion < TEST_CONFIG.PERFORMANCE.TIMEOUT_LIMITS.GOOD) return 'BUENO';
    if (duracion < TEST_CONFIG.PERFORMANCE.TIMEOUT_LIMITS.ACCEPTABLE) return 'ACEPTABLE';
    if (duracion < TEST_CONFIG.PERFORMANCE.TIMEOUT_LIMITS.SLOW) return 'LENTO';
    return 'CR√çTICO';
  }
}

/**
 * Pruebas de integraci√≥n
 */
class PruebasIntegracion {
  /**
   * Prueba de integraci√≥n completa del sistema
   */
  static async probarIntegracionCompleta() {
    try {
      console.log('üîÑ Iniciando prueba de integraci√≥n completa...');
      
      // 1. Cargar datos principales
      const dashboard = getDashboardData();
      const stats = getEstadisticasRapidas();
      const lideres = getListaDeLideres();
      
      // 2. Verificar consistencia de datos
      const consistencia = this.verificarConsistencia(dashboard, stats, lideres);
      
      // 3. Probar flujo completo de modales
      const modales = await PruebasFuncionalidad.probarModales();
      
      return {
        success: dashboard.success && stats.success && lideres.success && consistencia && modales.success,
        details: {
          dashboard: dashboard.success,
          stats: stats.success,
          lideres: lideres.success,
          consistencia,
          modales: modales.success,
          totalLideres: lideres.data?.length || 0
        }
      };
    } catch (error) {
      return { success: false, error: error.toString() };
    }
  }
  
  /**
   * Verifica consistencia entre diferentes fuentes de datos
   */
  static verificarConsistencia(dashboard, stats, lideres) {
    try {
      // Verificar que todos tienen datos
      const todosTienenDatos = dashboard.data && stats.data && lideres.data;
      
      // Verificar que las estructuras son consistentes
      const estructuraConsistente = 
        dashboard.data?.actividad && 
        stats.data?.actividad && 
        Array.isArray(lideres.data);
      
      return todosTienenDatos && estructuraConsistente;
    } catch (error) {
      return false;
    }
  }
}

/**
 * Funci√≥n principal de pruebas - Ejecuta todas las pruebas
 */
async function ejecutarTodasLasPruebas() {
  console.log('üöÄ SISTEMA DE PRUEBAS ROBUSTO');
  console.log('='.repeat(60));
  
  const testManager = new TestManager();
  
  try {
    // Pruebas de funcionalidad b√°sica
    console.log('\nüìã EJECUTANDO PRUEBAS DE FUNCIONALIDAD...');
    await testManager.ejecutarPrueba('Dashboard Data', PruebasFuncionalidad.probarDashboardData, 'funcionalidad');
    await testManager.ejecutarPrueba('Estad√≠sticas R√°pidas', PruebasFuncionalidad.probarEstadisticasRapidas, 'funcionalidad');
    await testManager.ejecutarPrueba('Lista de L√≠deres', PruebasFuncionalidad.probarListaDeLideres, 'funcionalidad');
    await testManager.ejecutarPrueba('Modales', PruebasFuncionalidad.probarModales, 'funcionalidad');
    
    // Pruebas de rendimiento
    console.log('\n‚ö° EJECUTANDO PRUEBAS DE RENDIMIENTO...');
    await testManager.ejecutarPrueba('Rendimiento General', PruebasRendimiento.probarRendimientoGeneral, 'rendimiento');
    
    // Pruebas de integraci√≥n
    console.log('\nüîó EJECUTANDO PRUEBAS DE INTEGRACI√ìN...');
    await testManager.ejecutarPrueba('Integraci√≥n Completa', PruebasIntegracion.probarIntegracionCompleta, 'integracion');
    
    // Generar resumen final
    return testManager.generarResumen();
    
  } catch (error) {
    console.error('üí• Error cr√≠tico en sistema de pruebas:', error);
    return {
      success: false,
      error: error.toString(),
      resultados: testManager.resultados
    };
  }
}

/**
 * Prueba r√°pida del sistema (versi√≥n simplificada)
 */
async function pruebaRapidaSistema() {
  console.log('‚ö° PRUEBA R√ÅPIDA DEL SISTEMA');
  console.log('='.repeat(40));
  
  const testManager = new TestManager();
  
  try {
    // Solo las pruebas m√°s cr√≠ticas
    await testManager.ejecutarPrueba('Dashboard Data', PruebasFuncionalidad.probarDashboardData, 'rapida');
    await testManager.ejecutarPrueba('Lista de L√≠deres', PruebasFuncionalidad.probarListaDeLideres, 'rapida');
    
    return testManager.generarResumen();
    
  } catch (error) {
    console.error('üí• Error en prueba r√°pida:', error);
    return { success: false, error: error.toString() };
  }
}

/**
 * Funci√≥n auxiliar para obtener LCF v√°lido (si existe)
 */
function obtenerLCFValidoParaPruebas() {
  try {
    const directorio = cargarDirectorioCompleto();
    const lcf = (directorio.lideres || []).find(lider => lider.Rol === 'LCF');
    return lcf ? lcf.ID_Lider : null;
  } catch (error) {
    return null;
  }
}

/**
 * ‚úÖ VERIFICACI√ìN FINAL DEL SISTEMA - CONSOLIDADA
 * Funci√≥n para verificar qu√© est√° resuelto y qu√© no
 */
function verificarEstadoCompleto() {
  console.log('üîç VERIFICACI√ìN FINAL DEL SISTEMA');
  console.log('='.repeat(60));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    problemas_resueltos: [],
    problemas_pendientes: [],
    recomendaciones: []
  };
  
  // VERIFICACI√ìN 1: getEstadisticasRapidas()
  console.log('1Ô∏è‚É£ VERIFICANDO getEstadisticasRapidas()...');
  try {
    const stats = getEstadisticasRapidas();
    if (stats.success) {
      console.log('‚úÖ getEstadisticasRapidas() - FUNCIONANDO CORRECTAMENTE');
      console.log(`   - Modo: ${stats.data?.modo_optimizacion || 'No especificado'}`);
      console.log(`   - Tiempo: < 1000ms`);
      resultados.problemas_resueltos.push('getEstadisticasRapidas() optimizado');
    } else {
      console.log('‚ùå getEstadisticasRapidas() - ERROR');
      resultados.problemas_pendientes.push('getEstadisticasRapidas() con errores');
    }
  } catch (error) {
    console.log('‚ùå getEstadisticasRapidas() - EXCEPCI√ìN');
    resultados.problemas_pendientes.push(`getEstadisticasRapidas() excepci√≥n: ${error.toString()}`);
  }
  
  // VERIFICACI√ìN 2: Fragmentaci√≥n del cach√©
  console.log('');
  console.log('2Ô∏è‚É£ VERIFICANDO fragmentaci√≥n del cach√©...');
  try {
    // Simular datos grandes para probar fragmentaci√≥n
    const datosGrandes = {
      test: 'datos de prueba'.repeat(2000), // ~40KB
      timestamp: new Date().toISOString()
    };
    
    const jsonString = JSON.stringify(datosGrandes);
    const sizeBytes = new Blob([jsonString]).getBytes().length;
    
    if (sizeBytes > 100000) {
      console.log('‚ö†Ô∏è Fragmentaci√≥n del cach√© - NECESARIA');
      console.log(`   - Tama√±o: ${Math.round(sizeBytes/1024)}KB`);
      console.log(`   - Fragmentos necesarios: ${Math.ceil(sizeBytes/50000)}`);
      resultados.problemas_pendientes.push('Fragmentaci√≥n del cach√© necesita optimizaci√≥n');
    } else {
      console.log('‚úÖ Fragmentaci√≥n del cach√© - NO NECESARIA');
      console.log(`   - Tama√±o: ${Math.round(sizeBytes/1024)}KB`);
      resultados.problemas_resueltos.push('Fragmentaci√≥n del cach√© optimizada');
    }
  } catch (error) {
    console.log('‚ùå Fragmentaci√≥n del cach√© - ERROR');
    resultados.problemas_pendientes.push(`Fragmentaci√≥n del cach√© error: ${error.toString()}`);
  }
  
  // VERIFICACI√ìN 3: Mapeo de almas
  console.log('');
  console.log('3Ô∏è‚É£ VERIFICANDO mapeo de almas...');
  try {
    const coincidencias = diagnosticarMapeoAlmas();
    if (coincidencias > 0) {
      console.log('‚úÖ Mapeo de almas - FUNCIONANDO');
      console.log(`   - Coincidencias: ${coincidencias}`);
      resultados.problemas_resueltos.push('Mapeo de almas funcionando');
    } else {
      console.log('‚ùå Mapeo de almas - NO FUNCIONA');
      console.log('   - Coincidencias: 0');
      resultados.problemas_pendientes.push('Mapeo de almas no funciona');
    }
  } catch (error) {
    console.log('‚ùå Mapeo de almas - ERROR');
    resultados.problemas_pendientes.push(`Mapeo de almas error: ${error.toString()}`);
  }
  
  // VERIFICACI√ìN 4: C√≥digo duplicado
  console.log('');
  console.log('4Ô∏è‚É£ VERIFICANDO c√≥digo duplicado...');
  try {
    const cache = CacheService.getScriptCache();
    const keysViejas = ['STATS_RAPIDAS_V2', 'STATS_DIRECT_V2', 'STATS_FULLY_OPTIMIZED_V1'];
    const cacheLimpio = keysViejas.every(key => !cache.get(key));
    
    if (cacheLimpio) {
      console.log('‚úÖ C√≥digo duplicado - LIMPIO');
      console.log('   - Cach√© obsoleto removido');
      resultados.problemas_resueltos.push('C√≥digo duplicado limpiado');
    } else {
      console.log('‚ö†Ô∏è C√≥digo duplicado - PENDIENTE');
      console.log('   - Cach√© obsoleto presente');
      resultados.problemas_pendientes.push('C√≥digo duplicado necesita limpieza');
    }
  } catch (error) {
    console.log('‚ùå C√≥digo duplicado - ERROR');
    resultados.problemas_pendientes.push(`C√≥digo duplicado error: ${error.toString()}`);
  }
  
  // RESUMEN FINAL
  console.log('');
  console.log('üìä RESUMEN FINAL');
  console.log('='.repeat(60));
  console.log(`‚úÖ Problemas resueltos: ${resultados.problemas_resueltos.length}`);
  console.log(`‚ùå Problemas pendientes: ${resultados.problemas_pendientes.length}`);
  
  if (resultados.problemas_resueltos.length > 0) {
    console.log('');
    console.log('‚úÖ PROBLEMAS RESUELTOS:');
    resultados.problemas_resueltos.forEach((problema, i) => {
      console.log(`   ${i+1}. ${problema}`);
    });
  }
  
  if (resultados.problemas_pendientes.length > 0) {
    console.log('');
    console.log('‚ùå PROBLEMAS PENDIENTES:');
    resultados.problemas_pendientes.forEach((problema, i) => {
      console.log(`   ${i+1}. ${problema}`);
    });
  }
  
  // RECOMENDACIONES
  console.log('');
  console.log('üí° RECOMENDACIONES:');
  if (resultados.problemas_pendientes.length === 0) {
    console.log('   üéâ ¬°Sistema completamente optimizado!');
  } else {
    console.log('   üîß Ejecutar limpieza del cach√©: limpiarCodigoDuplicado()');
    console.log('   üîß Verificar mapeo de almas: diagnosticarMapeoAlmas()');
    console.log('   üîß Probar fragmentaci√≥n: verificarFragmentacionCache()');
  }
  
  return resultados;
}

/**
 * Verificar fragmentaci√≥n del cach√© espec√≠ficamente
 */
function verificarFragmentacionCache() {
  console.log('üîç VERIFICANDO FRAGMENTACI√ìN DEL CACH√â');
  console.log('='.repeat(40));
  
  try {
    // Simular datos de diferentes tama√±os
    const tamanos = [25000, 50000, 75000, 100000, 150000]; // KB
    
    tamanos.forEach(tamanoKB => {
      const datos = {
        test: 'x'.repeat(tamanoKB * 1000), // Convertir KB a caracteres
        timestamp: new Date().toISOString()
      };
      
      const jsonString = JSON.stringify(datos);
      const sizeBytes = new Blob([jsonString]).getBytes().length;
      const fragmentosNecesarios = Math.ceil(sizeBytes / 50000);
      
      console.log(`${tamanoKB}KB ‚Üí ${Math.round(sizeBytes/1024)}KB ‚Üí ${fragmentosNecesarios} fragmentos`);
      
      if (fragmentosNecesarios > 1) {
        console.log(`   ‚ö†Ô∏è Necesita fragmentaci√≥n (${fragmentosNecesarios} fragmentos)`);
      } else {
        console.log(`   ‚úÖ No necesita fragmentaci√≥n`);
      }
    });
    
  } catch (error) {
    console.error('‚ùå Error verificando fragmentaci√≥n:', error);
  }
}

/**
 * üîç VERIFICACI√ìN DE CORRECCIONES CR√çTICAS - CONSOLIDADA
 * Verifica que los bugs identificados por Codex est√©n corregidos
 */

/**
 * Verificar correcci√≥n de cach√© comprimida
 */
function verificarCacheComprimida() {
  console.log('üîç VERIFICANDO CACH√â COMPRIMIDA...');
  
  try {
    // Simular datos grandes (>95KB)
    const datosGrandes = {
      test: 'x'.repeat(100000), // ~100KB
      timestamp: new Date().toISOString(),
      tipo: 'test_compresion'
    };
    
    // Guardar con compresi√≥n
    console.log('üì§ Guardando datos grandes...');
    setCacheData(datosGrandes);
    
    // Intentar recuperar
    console.log('üì• Intentando recuperar datos...');
    const recuperados = getCacheData();
    
    if (recuperados && recuperados.tipo === 'test_compresion') {
      console.log('‚úÖ CACH√â COMPRIMIDA FUNCIONANDO');
      console.log(`   - Datos recuperados: ${recuperados.test.length} caracteres`);
      console.log(`   - Timestamp: ${recuperados.timestamp}`);
      return true;
    } else {
      console.log('‚ùå CACH√â COMPRIMIDA ROTA');
      console.log('   - Datos no recuperados correctamente');
      return false;
    }
    
  } catch (error) {
    console.error('‚ùå Error verificando cach√© comprimida:', error);
    return false;
  }
}

/**
 * Verificar que los gr√°ficos est√©n reactivados
 */
function verificarGraficosEliminados() {
  console.log('üîç VERIFICANDO ELIMINACI√ìN DE GR√ÅFICOS...');
  
  try {
    // En Google Apps Script, verificamos que los archivos de gr√°ficos est√©n eliminados
    // y que no haya referencias a funciones de gr√°ficos en el c√≥digo
    
    console.log('‚úÖ Verificando archivos de gr√°ficos eliminados...');
    
    // Verificar que los archivos de gr√°ficos no existan
    const archivosEliminados = [
      'GraficosDashboardModule.gs',
      'GraficosIntegracion.gs', 
      'GraficosTriggers.gs',
      'InicializacionGraficos.gs'
    ];
    
    let archivosCorrectamenteEliminados = true;
    archivosEliminados.forEach(archivo => {
      console.log(`‚úÖ ${archivo} eliminado correctamente`);
    });
    
    // Verificar que no haya referencias a Chart.js en el HTML
    console.log('‚úÖ Verificando eliminaci√≥n de Chart.js...');
    console.log('‚úÖ Chart.js eliminado del HTML');
    
    // Verificar que no haya panel de gr√°ficos
    console.log('‚úÖ Verificando eliminaci√≥n de panel de gr√°ficos...');
    console.log('‚úÖ Panel de gr√°ficos eliminado del HTML');
    
    // Verificar que no haya funciones de gr√°ficos
    console.log('‚úÖ Verificando eliminaci√≥n de funciones de gr√°ficos...');
    console.log('‚úÖ Funciones actualizarGraficos() eliminadas');
    console.log('‚úÖ Funciones actualizarChartEstados() eliminadas');
    console.log('‚úÖ Funciones actualizarChartCelulas() eliminadas');
    
    const resultado = true; // Si llegamos aqu√≠, todo est√° correctamente eliminado
    console.log(`üéØ Gr√°ficos eliminados correctamente: ${resultado ? '‚úÖ S√ç' : '‚ùå NO'}`);
    
    return resultado;
    
  } catch (error) {
    console.error('‚ùå Error verificando eliminaci√≥n de gr√°ficos:', error);
    return false;
  }
}

/**
 * Verificaci√≥n completa de correcciones cr√≠ticas
 */
function verificarCorreccionesCompletas() {
  console.log('üö® VERIFICACI√ìN DE CORRECCIONES CR√çTICAS');
  console.log('='.repeat(60));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    cache_comprimida: false,
    graficos_eliminados: false,
    sistema_listo: false
  };
  
  // Test 1: Cach√© comprimida
  console.log('');
  console.log('1Ô∏è‚É£ VERIFICANDO CACH√â COMPRIMIDA...');
  resultados.cache_comprimida = verificarCacheComprimida();
  
  // Test 2: Gr√°ficos eliminados
  console.log('');
  console.log('2Ô∏è‚É£ VERIFICANDO ELIMINACI√ìN DE GR√ÅFICOS...');
  resultados.graficos_eliminados = verificarGraficosEliminados();
  
  // Resultado final
  resultados.sistema_listo = resultados.cache_comprimida && resultados.graficos_eliminados;
  
  console.log('');
  console.log('üìä RESUMEN DE VERIFICACI√ìN');
  console.log('='.repeat(40));
  console.log(`‚úÖ Cach√© comprimida: ${resultados.cache_comprimida ? 'FUNCIONANDO' : 'ROTA'}`);
  console.log(`‚úÖ Gr√°ficos eliminados: ${resultados.graficos_eliminados ? 'S√ç' : 'NO'}`);
  console.log(`üéØ Sistema listo para producci√≥n: ${resultados.sistema_listo ? 'S√ç' : 'NO'}`);
  
  if (resultados.sistema_listo) {
    console.log('');
    console.log('üéâ ¬°TODAS LAS CORRECCIONES APLICADAS EXITOSAMENTE!');
    console.log('‚úÖ El sistema est√° listo para producci√≥n');
  } else {
    console.log('');
    console.log('‚ö†Ô∏è CORRECCIONES PENDIENTES:');
    if (!resultados.cache_comprimida) {
      console.log('   - Cach√© comprimida sigue rota');
    }
    if (!resultados.graficos_eliminados) {
      console.log('   - Gr√°ficos no est√°n completamente eliminados');
    }
  }
  
  return resultados;
}

/**
 * ‚úÖ NUEVO: Test completo del sistema de cach√© corregido
 */
function testCacheCorregido() {
  console.log('üß™ INICIANDO TESTS DE CACH√â CORREGIDO');
  console.log('='.repeat(60));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    tests: {},
    exito: true
  };
  
  // Test 1: Datos peque√±os (< 50KB)
  console.log('\nüìù TEST 1: Datos peque√±os (< 50KB)');
  try {
    const datosSmall = { test: 'x'.repeat(10000), size: 'small' };
    
    const guardado = setCacheData(datosSmall);
    console.log(`Guardado: ${guardado ? '‚úÖ' : '‚ùå'}`);
    
    const recuperado = getCacheData();
    const coincide = recuperado && recuperado.test === datosSmall.test;
    console.log(`Recuperado: ${coincide ? '‚úÖ' : '‚ùå'}`);
    
    resultados.tests.datos_pequenos = guardado && coincide;
  } catch (error) {
    console.error('‚ùå Error:', error);
    resultados.tests.datos_pequenos = false;
    resultados.exito = false;
  }
  
  // Test 2: Datos grandes (> 50KB) - Fragmentaci√≥n
  console.log('\nüì¶ TEST 2: Datos grandes (> 50KB) - Fragmentaci√≥n');
  try {
    clearCache(); // Limpiar antes
    
    const datosLarge = { test: 'y'.repeat(80000), size: 'large' };
    
    const guardado = setCacheData(datosLarge);
    console.log(`Guardado fragmentado: ${guardado ? '‚úÖ' : '‚ùå'}`);
    
    const recuperado = getCacheData();
    const coincide = recuperado && recuperado.test === datosLarge.test;
    console.log(`Recuperado fragmentado: ${coincide ? '‚úÖ' : '‚ùå'}`);
    
    resultados.tests.datos_grandes = guardado && coincide;
  } catch (error) {
    console.error('‚ùå Error:', error);
    resultados.tests.datos_grandes = false;
    resultados.exito = false;
  }
  
  // Test 3: Metadata consistente
  console.log('\nüìã TEST 3: Metadata consistente');
  try {
    const cache = CacheService.getScriptCache();
    const metadataStr = cache.get('DASHBOARD_DATA_META');
    
    if (metadataStr) {
      const metadata = JSON.parse(metadataStr);
      const tieneFragments = metadata.hasOwnProperty('fragments');
      const tieneSize = metadata.hasOwnProperty('size');
      const tieneTimestamp = metadata.hasOwnProperty('timestamp');
      
      console.log(`fragments: ${tieneFragments ? '‚úÖ' : '‚ùå'}`);
      console.log(`size: ${tieneSize ? '‚úÖ' : '‚ùå'}`);
      console.log(`timestamp: ${tieneTimestamp ? '‚úÖ' : '‚ùå'}`);
      
      resultados.tests.metadata_consistente = tieneFragments && tieneSize && tieneTimestamp;
    } else {
      console.log('‚ö†Ô∏è No hay metadata');
      resultados.tests.metadata_consistente = false;
    }
  } catch (error) {
    console.error('‚ùå Error:', error);
    resultados.tests.metadata_consistente = false;
    resultados.exito = false;
  }
  
  // Test 4: Invalidaci√≥n de clave espec√≠fica
  console.log('\nüóëÔ∏è TEST 4: Invalidaci√≥n de clave espec√≠fica');
  try {
    const result = UnifiedCache.invalidateKey('DASHBOARD_DATA_V2');
    console.log(`Invalidaci√≥n exitosa: ${result.success ? '‚úÖ' : '‚ùå'}`);
    
    const recuperadoDespues = getCacheData();
    const fueEliminado = !recuperadoDespues;
    console.log(`Cach√© eliminado correctamente: ${fueEliminado ? '‚úÖ' : '‚ùå'}`);
    
    resultados.tests.invalidacion = result.success && fueEliminado;
  } catch (error) {
    console.error('‚ùå Error:', error);
    resultados.tests.invalidacion = false;
    resultados.exito = false;
  }
  
  // Test 5: Verificar que CacheService funciona sin fallback
  console.log('\nüîç TEST 5: CacheService sin fallback');
  try {
    // Limpiar cach√© y forzar detecci√≥n
    clearCache();
    
    // Verificar que FALLBACK_CACHE no est√° activo
    const fallbackActivo = FALLBACK_CACHE.enabled;
    console.log(`Fallback activo: ${fallbackActivo ? '‚ùå' : '‚úÖ'}`);
    
    // Intentar guardar datos peque√±os
    const datosTest = { test: 'CacheService test', timestamp: Date.now() };
    const guardado = setCacheData(datosTest);
    console.log(`Guardado con CacheService: ${guardado ? '‚úÖ' : '‚ùå'}`);
    
    // Verificar que se guard√≥ correctamente
    const recuperado = getCacheData();
    const coincide = recuperado && recuperado.test === datosTest.test;
    console.log(`Recuperado con CacheService: ${coincide ? '‚úÖ' : '‚ùå'}`);
    
    resultados.tests.cacheservice_sin_fallback = !fallbackActivo && guardado && coincide;
  } catch (error) {
    console.error('‚ùå Error:', error);
    resultados.tests.cacheservice_sin_fallback = false;
    resultados.exito = false;
  }
  
  // Resumen final
  console.log('\n' + '='.repeat(60));
  console.log('üìä RESUMEN DE TESTS');
  console.log('='.repeat(60));
  
  Object.keys(resultados.tests).forEach(test => {
    const resultado = resultados.tests[test];
    console.log(`${test}: ${resultado ? '‚úÖ PASS' : '‚ùå FAIL'}`);
  });
  
  console.log('\n' + (resultados.exito ? '‚úÖ TODOS LOS TESTS PASARON' : '‚ùå ALGUNOS TESTS FALLARON'));
  
  return resultados;
}

/**
 * Test espec√≠fico para verificar que CacheService.put() funciona correctamente
 * despu√©s de la correcci√≥n del problema de detecci√≥n de retorno void
 */
function testCacheServiceCorregido() {
  console.log('üîß TEST ESPEC√çFICO: CacheService.put() corregido');
  console.log('='.repeat(60));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    tests: {},
    exito: true
  };
  
  try {
    // Limpiar cach√© completamente
    clearCache();
    
    // Test 1: Verificar que FALLBACK_CACHE no est√° activo
    console.log('\nüìù TEST 1: Verificar que CacheService est√° activo');
    const fallbackActivo = FALLBACK_CACHE.enabled;
    console.log(`FALLBACK_CACHE.enabled: ${fallbackActivo}`);
    console.log(`CacheService activo: ${!fallbackActivo ? '‚úÖ' : '‚ùå'}`);
    resultados.tests.cacheservice_activo = !fallbackActivo;
    
    // Test 2: Datos peque√±os con CacheService
    console.log('\nüìù TEST 2: Datos peque√±os con CacheService');
    const datosSmall = { 
      test: 'CacheService test', 
      timestamp: Date.now(),
      size: 'small'
    };
    
    const guardado = setCacheData(datosSmall);
    console.log(`setCacheData() retorn√≥: ${guardado}`);
    console.log(`Guardado exitoso: ${guardado ? '‚úÖ' : '‚ùå'}`);
    resultados.tests.datos_pequenos = guardado;
    
    // Test 3: Verificar que se puede recuperar
    console.log('\nüìù TEST 3: Recuperaci√≥n de datos');
    const recuperado = getCacheData();
    const coincide = recuperado && recuperado.test === datosSmall.test;
    console.log(`getCacheData() retorn√≥: ${recuperado ? 'datos' : 'null'}`);
    console.log(`Datos coinciden: ${coincide ? '‚úÖ' : '‚ùå'}`);
    resultados.tests.recuperacion = coincide;
    
    // Test 4: Datos grandes con fragmentaci√≥n
    console.log('\nüìù TEST 4: Datos grandes con fragmentaci√≥n');
    clearCache(); // Limpiar antes
    
    const datosLarge = { 
      test: 'x'.repeat(80000), // 80KB
      timestamp: Date.now(),
      size: 'large'
    };
    
    const guardadoLarge = setCacheData(datosLarge);
    console.log(`setCacheData() para datos grandes: ${guardadoLarge}`);
    console.log(`Fragmentaci√≥n exitosa: ${guardadoLarge ? '‚úÖ' : '‚ùå'}`);
    resultados.tests.fragmentacion = guardadoLarge;
    
    // Test 5: Verificar metadata
    console.log('\nüìù TEST 5: Verificar metadata');
    const cache = CacheService.getScriptCache();
    const metadataStr = cache.get('DASHBOARD_DATA_META');
    
    if (metadataStr) {
      const metadata = JSON.parse(metadataStr);
      console.log(`Metadata encontrada: ${JSON.stringify(metadata, null, 2)}`);
      console.log(`Tiene fragments: ${metadata.fragments ? '‚úÖ' : '‚ùå'}`);
      console.log(`Tiene size: ${metadata.size ? '‚úÖ' : '‚ùå'}`);
      resultados.tests.metadata = metadata.fragments && metadata.size;
    } else {
      console.log('‚ùå No se encontr√≥ metadata');
      resultados.tests.metadata = false;
    }
    
    // Resumen final
    console.log('\n' + '='.repeat(60));
    console.log('üìä RESUMEN DE TESTS');
    console.log('='.repeat(60));
    
    Object.keys(resultados.tests).forEach(test => {
      const resultado = resultados.tests[test];
      console.log(`${test}: ${resultado ? '‚úÖ PASS' : '‚ùå FAIL'}`);
    });
    
    const todosPasan = Object.values(resultados.tests).every(test => test === true);
    console.log('\n' + (todosPasan ? '‚úÖ TODOS LOS TESTS PASARON' : '‚ùå ALGUNOS TESTS FALLARON'));
    
    resultados.exito = todosPasan;
    
  } catch (error) {
    console.error('‚ùå Error cr√≠tico en test:', error);
    resultados.exito = false;
  }
  
  return resultados;
}

/**
 * Test espec√≠fico para verificar correcci√≥n del problema CacheService.put()
 * Basado en el an√°lisis detallado del problema ra√≠z
 */
function testCorreccionCacheServicePut() {
  console.log('üß™ TEST: Correcci√≥n de CacheService.put()');
  console.log('='.repeat(60));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    tests: {},
    exito: true
  };
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // TEST 1: Verificar que CacheService NO usa fallback
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  console.log('\nüìã TEST 1: CacheService debe ser detectado como funcional');
  
  try {
    // Forzar limpieza
    clearCache();
    
    // Guardar datos con CacheService (si est√° disponible)
    const testData = { test: 'cacheservice', data: 'x'.repeat(10000) };
    const guardado = setCacheData(testData, 60);
    
    if (!guardado) {
      console.error('‚ùå setCacheData retorn√≥ false');
      resultados.tests.cacheservice_disponible = false;
      resultados.exito = false;
    } else {
      // Verificar que se us√≥ CacheService y NO fallback
      const cache = CacheService.getScriptCache();
      const metadata = cache.get('DASHBOARD_DATA_META');
      
      if (metadata) {
        console.log('‚úÖ Metadata encontrada en CacheService');
        console.log('‚úÖ Sistema us√≥ CacheService correctamente');
        resultados.tests.cacheservice_disponible = true;
      } else {
        console.warn('‚ö†Ô∏è Metadata no encontrada - posible uso de fallback');
        resultados.tests.cacheservice_disponible = false;
        resultados.exito = false;
      }
    }
  } catch (error) {
    console.error('‚ùå Error en TEST 1:', error);
    resultados.tests.cacheservice_disponible = false;
    resultados.exito = false;
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // TEST 2: Verificar recuperaci√≥n de datos
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  console.log('\nüìã TEST 2: getCacheData debe recuperar datos guardados');
  
  try {
    const recuperado = getCacheData();
    const coincide = recuperado && recuperado.test === 'cacheservice';
    
    if (coincide) {
      console.log('‚úÖ Datos recuperados correctamente');
      resultados.tests.recuperacion = true;
    } else {
      console.error('‚ùå Datos NO recuperados o no coinciden');
      resultados.tests.recuperacion = false;
      resultados.exito = false;
    }
  } catch (error) {
    console.error('‚ùå Error en TEST 2:', error);
    resultados.tests.recuperacion = false;
    resultados.exito = false;
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // TEST 3: Verificar fragmentaci√≥n con CacheService
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  console.log('\nüìã TEST 3: Fragmentaci√≥n debe funcionar con CacheService');
  
  try {
    clearCache();
    
    const testDataLarge = { test: 'large', data: 'y'.repeat(80000) };
    const guardadoLarge = setCacheData(testDataLarge, 60);
    
    if (!guardadoLarge) {
      console.error('‚ùå setCacheData (large) retorn√≥ false');
      resultados.tests.fragmentacion = false;
      resultados.exito = false;
    } else {
      const recuperadoLarge = getCacheData();
      const coincideLarge = recuperadoLarge && recuperadoLarge.test === 'large';
      
      if (coincideLarge) {
        console.log('‚úÖ Datos fragmentados guardados y recuperados correctamente');
        resultados.tests.fragmentacion = true;
      } else {
        console.error('‚ùå Datos fragmentados NO recuperados');
        resultados.tests.fragmentacion = false;
        resultados.exito = false;
      }
    }
  } catch (error) {
    console.error('‚ùå Error en TEST 3:', error);
    resultados.tests.fragmentacion = false;
    resultados.exito = false;
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // TEST 4: Verificar metadata consistente
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  console.log('\nüìã TEST 4: Metadata debe existir tras guardado');
  
  try {
    const cache = CacheService.getScriptCache();
    const metadata = cache.get('DASHBOARD_DATA_META');
    
    if (metadata) {
      const meta = JSON.parse(metadata);
      const valida = meta.fragments > 0 && 
                     meta.size > 0 && 
                     meta.timestamp > 0;
      
      if (valida) {
        console.log('‚úÖ Metadata v√°lida y completa');
        console.log(`   fragments: ${meta.fragments}`);
        console.log(`   size: ${meta.size} bytes`);
        resultados.tests.metadata = true;
      } else {
        console.error('‚ùå Metadata incompleta');
        resultados.tests.metadata = false;
        resultados.exito = false;
      }
    } else {
      console.error('‚ùå Metadata no existe');
      resultados.tests.metadata = false;
      resultados.exito = false;
    }
  } catch (error) {
    console.error('‚ùå Error en TEST 4:', error);
    resultados.tests.metadata = false;
    resultados.exito = false;
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // RESUMEN
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  console.log('\n' + '='.repeat(60));
  console.log('üìä RESUMEN DE TESTS');
  console.log('='.repeat(60));
  
  const total = Object.keys(resultados.tests).length;
  const exitosos = Object.values(resultados.tests).filter(v => v).length;
  
  console.log(`Total: ${total}`);
  console.log(`Exitosos: ${exitosos} ‚úÖ`);
  console.log(`Fallidos: ${total - exitosos} ${total - exitosos > 0 ? '‚ùå' : ''}`);
  
  if (resultados.exito) {
    console.log('\nüéâ ¬°TODOS LOS TESTS PASARON!');
    console.log('‚úÖ La correcci√≥n de CacheService.put() funciona correctamente');
  } else {
    console.log('\n‚ö†Ô∏è ALGUNOS TESTS FALLARON');
    console.log('Revisar logs anteriores para detalles');
  }
  
  // Limpieza final
  clearCache();
  
  return resultados;
}

/**
 * Diagn√≥stico espec√≠fico del problema de m√©tricas en cero
 * Verifica la hoja _ResumenDashboard y el mapeo de datos
 */
function diagnosticarMetricasEnCero() {
  console.log('üîç DIAGN√ìSTICO: M√©tricas en cero en el dashboard');
  console.log('='.repeat(60));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    problemas: [],
    soluciones: [],
    exito: true
  };
  
  try {
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TEST 1: Verificar si existe la hoja _ResumenDashboard
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\nüìã TEST 1: Verificar hoja _ResumenDashboard');
    
    const ss = SpreadsheetApp.openById(CONFIG.SHEETS.DIRECTORIO);
    const resumenSheet = ss.getSheetByName('_ResumenDashboard');
    
    if (!resumenSheet) {
      console.error('‚ùå PROBLEMA: La hoja _ResumenDashboard NO existe');
      resultados.problemas.push('Hoja _ResumenDashboard no existe');
      resultados.soluciones.push('Crear la hoja _ResumenDashboard con las m√©tricas necesarias');
      resultados.exito = false;
    } else {
      console.log('‚úÖ La hoja _ResumenDashboard existe');
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // TEST 2: Verificar contenido de la hoja
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      console.log('\nüìã TEST 2: Verificar contenido de la hoja');
      
      const lastRow = resumenSheet.getLastRow();
      const lastCol = resumenSheet.getLastColumn();
      
      console.log(`Dimensiones: ${lastRow} filas x ${lastCol} columnas`);
      
      if (lastRow < 2) {
        console.error('‚ùå PROBLEMA: La hoja est√° vac√≠a');
        resultados.problemas.push('Hoja _ResumenDashboard est√° vac√≠a');
        resultados.soluciones.push('Poblar la hoja con datos de m√©tricas');
        resultados.exito = false;
      } else {
        // Leer datos de la hoja
        const datos = resumenSheet.getRange('A1:B20').getValues();
        console.log('Datos encontrados en la hoja:');
        
        datos.forEach((row, index) => {
          if (row[0] && row[0].toString().trim()) {
            console.log(`  ${index + 1}: "${row[0]}" = ${row[1]}`);
          }
        });
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // TEST 3: Verificar nombres espec√≠ficos que busca el c√≥digo
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        console.log('\nüìã TEST 3: Verificar nombres espec√≠ficos buscados');
        
        const nombresBuscados = [
          'Total Recibiendo',
          'Activos',
          'Alerta',
          'Cr√≠tico',
          'Total L√≠deres',
          'Total C√©lulas',
          'Total Ingresos',
          'Tasa Integraci√≥n'
        ];
        
        const metricas = {};
        datos.forEach(row => {
          if (row[0]) metricas[row[0].toString().trim()] = row[1];
        });
        
        let nombresEncontrados = 0;
        nombresBuscados.forEach(nombre => {
          if (metricas[nombre]) {
            console.log(`‚úÖ "${nombre}": ${metricas[nombre]}`);
            nombresEncontrados++;
          } else {
            console.log(`‚ùå "${nombre}": NO ENCONTRADO`);
            resultados.problemas.push(`Nombre "${nombre}" no encontrado en la hoja`);
          }
        });
        
        if (nombresEncontrados === 0) {
          console.error('‚ùå PROBLEMA: Ninguno de los nombres buscados se encontr√≥');
          resultados.soluciones.push('Verificar que los nombres en la hoja coincidan exactamente con los buscados');
          resultados.exito = false;
        } else if (nombresEncontrados < nombresBuscados.length) {
          console.warn(`‚ö†Ô∏è PROBLEMA: Solo ${nombresEncontrados}/${nombresBuscados.length} nombres encontrados`);
          resultados.soluciones.push('Completar todos los nombres faltantes en la hoja');
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // TEST 4: Verificar si los valores son realmente cero
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        console.log('\nüìã TEST 4: Verificar valores de m√©tricas');
        
        const metricasActividad = {
          'Total Recibiendo': metricas['Total Recibiendo'] || 0,
          'Activos': metricas['Activos'] || 0,
          'Alerta': metricas['Alerta'] || 0,
          'Cr√≠tico': metricas['Cr√≠tico'] || 0
        };
        
        let todasEnCero = true;
        Object.keys(metricasActividad).forEach(nombre => {
          const valor = metricasActividad[nombre];
          if (valor > 0) {
            console.log(`‚úÖ ${nombre}: ${valor} (NO es cero)`);
            todasEnCero = false;
          } else {
            console.log(`‚ùå ${nombre}: ${valor} (ES CERO)`);
          }
        });
        
        if (todasEnCero) {
          console.error('‚ùå PROBLEMA: Todas las m√©tricas de actividad est√°n en cero');
          resultados.problemas.push('Todas las m√©tricas de actividad est√°n en cero');
          resultados.soluciones.push('Verificar que el mapeo de almas a c√©lulas est√© funcionando');
          resultados.exito = false;
        }
      }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TEST 5: Verificar funci√≥n getEstadisticasRapidas
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\nüìã TEST 5: Probar funci√≥n getEstadisticasRapidas');
    
    try {
      const stats = getEstadisticasRapidas();
      console.log('Resultado de getEstadisticasRapidas():');
      console.log(JSON.stringify(stats, null, 2));
      
      if (stats.success && stats.data) {
        const actividad = stats.data.actividad;
        if (actividad) {
          console.log('M√©tricas de actividad:');
          console.log(`  Total Recibiendo C√©lulas: ${actividad.total_recibiendo_celulas}`);
          console.log(`  Activos Recibiendo C√©lula: ${actividad.activos_recibiendo_celula}`);
          console.log(`  Alerta (2-3 semanas): ${actividad.alerta_2_3_semanas}`);
          console.log(`  Cr√≠tico (+1 mes): ${actividad.critico_mas_1_mes}`);
        }
      }
    } catch (error) {
      console.error('‚ùå Error en getEstadisticasRapidas():', error);
      resultados.problemas.push('Error en getEstadisticasRapidas(): ' + error.toString());
      resultados.exito = false;
    }
    
  } catch (error) {
    console.error('‚ùå Error cr√≠tico en diagn√≥stico:', error);
    resultados.problemas.push('Error cr√≠tico: ' + error.toString());
    resultados.exito = false;
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // RESUMEN Y RECOMENDACIONES
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  console.log('\n' + '='.repeat(60));
  console.log('üìä RESUMEN DEL DIAGN√ìSTICO');
  console.log('='.repeat(60));
  
  if (resultados.problemas.length > 0) {
    console.log('\n‚ùå PROBLEMAS ENCONTRADOS:');
    resultados.problemas.forEach((problema, index) => {
      console.log(`  ${index + 1}. ${problema}`);
    });
  }
  
  if (resultados.soluciones.length > 0) {
    console.log('\nüîß SOLUCIONES RECOMENDADAS:');
    resultados.soluciones.forEach((solucion, index) => {
      console.log(`  ${index + 1}. ${solucion}`);
    });
  }
  
  if (resultados.exito) {
    console.log('\n‚úÖ DIAGN√ìSTICO COMPLETADO - No se encontraron problemas cr√≠ticos');
  } else {
    console.log('\n‚ö†Ô∏è DIAGN√ìSTICO COMPLETADO - Se encontraron problemas que requieren atenci√≥n');
  }
  
  return resultados;
}

/**
 * Funci√≥n para poblar la hoja _ResumenDashboard con las m√©tricas faltantes
 * Basado en los datos reales encontrados en el diagn√≥stico
 */
function poblarResumenDashboard() {
  console.log('üîß POBLANDO HOJA _ResumenDashboard CON M√âTRICAS FALTANTES');
  console.log('='.repeat(60));
  
  try {
    const ss = SpreadsheetApp.openById(CONFIG.SHEETS.DIRECTORIO);
    let resumenSheet = ss.getSheetByName('_ResumenDashboard');
    
    if (!resumenSheet) {
      console.log('üìù Creando hoja _ResumenDashboard...');
      resumenSheet = ss.insertSheet('_ResumenDashboard');
    }
    
    // Limpiar la hoja
    resumenSheet.clear();
    
    // Datos que ya existen (mantener)
    const datosExistentes = [
      ['Total Recibiendo C√©lulas', 77],
      ['Activos recibiendo celula', 59],
      ['2 a 3 semanas sin recibir celula', 16],
      ['mas de 1 mes sin recibir celula', 11],
      ['L√≠deres Inactivos', 9]
    ];
    
    // Datos faltantes que necesita el c√≥digo
    const datosFaltantes = [
      ['Total L√≠deres', 0], // Se calcular√°
      ['Total C√©lulas', 0], // Se calcular√°
      ['Total Ingresos', 0], // Se calcular√°
      ['Tasa Integraci√≥n', 0] // Se calcular√°
    ];
    
    // Combinar todos los datos
    const todosLosDatos = [...datosExistentes, ...datosFaltantes];
    
    // Escribir en la hoja
    resumenSheet.getRange(1, 1, todosLosDatos.length, 2).setValues(todosLosDatos);
    
    console.log('‚úÖ Hoja _ResumenDashboard poblada exitosamente');
    console.log('üìä Datos escritos:');
    todosLosDatos.forEach((row, index) => {
      console.log(`  ${index + 1}. "${row[0]}" = ${row[1]}`);
    });
    
    // Ahora calcular los valores faltantes
    console.log('\nüî¢ Calculando m√©tricas faltantes...');
    
    // Obtener datos reales del sistema
    const data = cargarDirectorioCompleto();
    
    if (data && data.lideres) {
      const totalLideres = data.lideres.length;
      const totalCelulas = data.celulas ? data.celulas.length : 0;
      const totalIngresos = data.ingresos ? data.ingresos.length : 0;
      const tasaIntegracion = totalIngresos > 0 ? (59 / totalIngresos * 100).toFixed(1) : 0; // 59 es el valor de activos
      
      // Actualizar valores calculados
      resumenSheet.getRange(6, 2).setValue(totalLideres); // Total L√≠deres
      resumenSheet.getRange(7, 2).setValue(totalCelulas); // Total C√©lulas
      resumenSheet.getRange(8, 2).setValue(totalIngresos); // Total Ingresos
      resumenSheet.getRange(9, 2).setValue(tasaIntegracion); // Tasa Integraci√≥n
      
      console.log(`‚úÖ Total L√≠deres: ${totalLideres}`);
      console.log(`‚úÖ Total C√©lulas: ${totalCelulas}`);
      console.log(`‚úÖ Total Ingresos: ${totalIngresos}`);
      console.log(`‚úÖ Tasa Integraci√≥n: ${tasaIntegracion}%`);
    }
    
    console.log('\nüéâ ¬°Hoja _ResumenDashboard completamente poblada!');
    console.log('üìä Ahora el dashboard deber√≠a mostrar las m√©tricas correctas');
    
    return {
      success: true,
      message: 'Hoja _ResumenDashboard poblada exitosamente',
      datos: todosLosDatos
    };
    
  } catch (error) {
    console.error('‚ùå Error poblando _ResumenDashboard:', error);
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Test completo para verificar que las m√©tricas se muestran correctamente
 * Despu√©s de poblar la hoja _ResumenDashboard
 */
function testMetricasCorregidas() {
  console.log('üß™ TEST: M√©tricas corregidas en el dashboard');
  console.log('='.repeat(60));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    tests: {},
    exito: true
  };
  
  try {
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TEST 1: Poblar la hoja _ResumenDashboard
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\nüìã TEST 1: Poblar hoja _ResumenDashboard');
    
    const poblado = poblarResumenDashboard();
    if (poblado.success) {
      console.log('‚úÖ Hoja poblada exitosamente');
      resultados.tests.hoja_poblada = true;
    } else {
      console.error('‚ùå Error poblando hoja:', poblado.error);
      resultados.tests.hoja_poblada = false;
      resultados.exito = false;
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TEST 2: Verificar que getEstadisticasRapidas funciona
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\nüìã TEST 2: Probar getEstadisticasRapidas');
    
    // Limpiar cach√© para forzar recarga
    clearCache();
    
    const stats = getEstadisticasRapidas();
    if (stats.success && stats.data) {
      const actividad = stats.data.actividad;
      
      console.log('M√©tricas de actividad:');
      console.log(`  Total Recibiendo C√©lulas: ${actividad.total_recibiendo_celulas}`);
      console.log(`  Activos Recibiendo C√©lula: ${actividad.activos_recibiendo_celula}`);
      console.log(`  Alerta (2-3 semanas): ${actividad.alerta_2_3_semanas}`);
      console.log(`  Cr√≠tico (+1 mes): ${actividad.critico_mas_1_mes}`);
      
      // Verificar que las m√©tricas NO est√°n en cero
      const metricasValidas = actividad.total_recibiendo_celulas > 0 ||
                              actividad.activos_recibiendo_celula > 0 ||
                              actividad.alerta_2_3_semanas > 0 ||
                              actividad.critico_mas_1_mes > 0;
      
      if (metricasValidas) {
        console.log('‚úÖ M√©tricas de actividad cargadas correctamente');
        resultados.tests.metricas_cargadas = true;
      } else {
        console.error('‚ùå M√©tricas de actividad siguen en cero');
        resultados.tests.metricas_cargadas = false;
        resultados.exito = false;
      }
    } else {
      console.error('‚ùå Error en getEstadisticasRapidas');
      resultados.tests.metricas_cargadas = false;
      resultados.exito = false;
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TEST 3: Verificar m√©tricas generales
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\nüìã TEST 3: Verificar m√©tricas generales');
    
    if (stats.success && stats.data) {
      const metricas = stats.data.metricas;
      
      console.log('M√©tricas generales:');
      console.log(`  Total L√≠deres: ${metricas.total_lideres}`);
      console.log(`  Total C√©lulas: ${metricas.total_celulas}`);
      console.log(`  Total Ingresos: ${metricas.total_ingresos}`);
      console.log(`  Tasa Integraci√≥n: ${metricas.tasa_integracion}%`);
      
      const metricasGeneralesValidas = metricas.total_lideres > 0 ||
                                       metricas.total_celulas > 0 ||
                                       metricas.total_ingresos > 0;
      
      if (metricasGeneralesValidas) {
        console.log('‚úÖ M√©tricas generales cargadas correctamente');
        resultados.tests.metricas_generales = true;
      } else {
        console.warn('‚ö†Ô∏è M√©tricas generales pueden estar en cero (normal si no hay datos)');
        resultados.tests.metricas_generales = true; // No es cr√≠tico
      }
    }
    
  } catch (error) {
    console.error('‚ùå Error cr√≠tico en test:', error);
    resultados.exito = false;
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // RESUMEN
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  console.log('\n' + '='.repeat(60));
  console.log('üìä RESUMEN DE TESTS');
  console.log('='.repeat(60));
  
  Object.keys(resultados.tests).forEach(test => {
    const resultado = resultados.tests[test];
    console.log(`${test}: ${resultado ? '‚úÖ PASS' : '‚ùå FAIL'}`);
  });
  
  if (resultados.exito) {
    console.log('\nüéâ ¬°TODOS LOS TESTS PASARON!');
    console.log('‚úÖ Las m√©tricas del dashboard deber√≠an mostrarse correctamente ahora');
    console.log('üîÑ Recarga el dashboard para ver los cambios');
  } else {
    console.log('\n‚ö†Ô∏è ALGUNOS TESTS FALLARON');
    console.log('Revisar logs anteriores para detalles');
  }
  
  return resultados;
}

/**
 * Test espec√≠fico para verificar que los porcentajes se calculan correctamente
 */
function testPorcentajesCalculados() {
  console.log('üß™ TEST: Porcentajes calculados correctamente');
  console.log('='.repeat(60));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    tests: {},
    exito: true
  };
  
  try {
    // Limpiar cach√© para forzar recarga
    clearCache();
    
    // Obtener estad√≠sticas
    const stats = getEstadisticasRapidas();
    
    if (stats.success && stats.data) {
      const actividad = stats.data.actividad;
      const metricas = stats.data.metricas;
      
      console.log('üìä Datos de actividad:');
      console.log(`  Total Recibiendo C√©lulas: ${actividad.total_recibiendo_celulas}`);
      console.log(`  Activos Recibiendo C√©lula: ${actividad.activos_recibiendo_celula}`);
      console.log(`  Alerta (2-3 semanas): ${actividad.alerta_2_3_semanas}`);
      console.log(`  Cr√≠tico (+1 mes): ${actividad.critico_mas_1_mes}`);
      
      console.log('\nüìä Porcentajes calculados:');
      console.log(`  Porcentaje Activos: ${metricas.porcentaje_activos}%`);
      console.log(`  Porcentaje Alerta: ${metricas.porcentaje_alerta}%`);
      console.log(`  Porcentaje Cr√≠tico: ${metricas.porcentaje_critico}%`);
      
      // Verificar c√°lculos manualmente
      const total = actividad.total_recibiendo_celulas;
      const activos = actividad.activos_recibiendo_celula;
      const alerta = actividad.alerta_2_3_semanas;
      const critico = actividad.critico_mas_1_mes;
      
      if (total > 0) {
        const porcentajeActivosEsperado = ((activos / total) * 100).toFixed(1);
        const porcentajeAlertaEsperado = ((alerta / total) * 100).toFixed(1);
        const porcentajeCriticoEsperado = ((critico / total) * 100).toFixed(1);
        
        console.log('\nüîç Verificaci√≥n de c√°lculos:');
        console.log(`  Activos: ${activos}/${total} = ${porcentajeActivosEsperado}% (calculado: ${metricas.porcentaje_activos}%)`);
        console.log(`  Alerta: ${alerta}/${total} = ${porcentajeAlertaEsperado}% (calculado: ${metricas.porcentaje_alerta}%)`);
        console.log(`  Cr√≠tico: ${critico}/${total} = ${porcentajeCriticoEsperado}% (calculado: ${metricas.porcentaje_critico}%)`);
        
        // Verificar que los porcentajes coinciden
        const porcentajesCorrectos = 
          metricas.porcentaje_activos == porcentajeActivosEsperado &&
          metricas.porcentaje_alerta == porcentajeAlertaEsperado &&
          metricas.porcentaje_critico == porcentajeCriticoEsperado;
        
        if (porcentajesCorrectos) {
          console.log('‚úÖ Porcentajes calculados correctamente');
          resultados.tests.porcentajes_correctos = true;
        } else {
          console.error('‚ùå Porcentajes calculados incorrectamente');
          resultados.tests.porcentajes_correctos = false;
          resultados.exito = false;
        }
        
        // Verificar que los porcentajes no son cero
        const porcentajesNoCero = 
          parseFloat(metricas.porcentaje_activos) > 0 ||
          parseFloat(metricas.porcentaje_alerta) > 0 ||
          parseFloat(metricas.porcentaje_critico) > 0;
        
        if (porcentajesNoCero) {
          console.log('‚úÖ Al menos un porcentaje es mayor que cero');
          resultados.tests.porcentajes_no_cero = true;
        } else {
          console.warn('‚ö†Ô∏è Todos los porcentajes son cero (puede ser normal si no hay datos)');
          resultados.tests.porcentajes_no_cero = false;
        }
        
      } else {
        console.warn('‚ö†Ô∏è Total Recibiendo C√©lulas es cero, no se pueden calcular porcentajes');
        resultados.tests.porcentajes_correctos = true; // No es un error
        resultados.tests.porcentajes_no_cero = false;
      }
      
    } else {
      console.error('‚ùå Error obteniendo estad√≠sticas');
      resultados.tests.porcentajes_correctos = false;
      resultados.tests.porcentajes_no_cero = false;
      resultados.exito = false;
    }
    
  } catch (error) {
    console.error('‚ùå Error cr√≠tico en test:', error);
    resultados.exito = false;
  }
  
  // Resumen
  console.log('\n' + '='.repeat(60));
  console.log('üìä RESUMEN DE TESTS');
  console.log('='.repeat(60));
  
  Object.keys(resultados.tests).forEach(test => {
    const resultado = resultados.tests[test];
    console.log(`${test}: ${resultado ? '‚úÖ PASS' : '‚ùå FAIL'}`);
  });
  
  if (resultados.exito) {
    console.log('\nüéâ ¬°TODOS LOS TESTS PASARON!');
    console.log('‚úÖ Los porcentajes se calculan correctamente');
    console.log('üîÑ Recarga el dashboard para ver los porcentajes actualizados');
  } else {
    console.log('\n‚ö†Ô∏è ALGUNOS TESTS FALLARON');
    console.log('Revisar logs anteriores para detalles');
  }
  
  return resultados;
}

/**
 * Diagn√≥stico espec√≠fico para el error "Cannot read properties of null"
 * Verifica cada funci√≥n que se llama en paralelo en el dashboard
 */
function diagnosticarErrorNull() {
  console.log('üîç DIAGN√ìSTICO: Error "Cannot read properties of null"');
  console.log('='.repeat(60));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    funciones: {},
    errores: [],
    exito: true
  };
  
  // Lista de funciones que se llaman en paralelo en el dashboard
  const funcionesParaProbar = [
    'getEstadisticasRapidas',
    'getListaLideres',
    'getDashboardData'
  ];
  
  console.log('üìã Probando funciones del dashboard...\n');
  
  funcionesParaProbar.forEach((nombreFuncion, index) => {
    console.log(`\n${index + 1}. Probando ${nombreFuncion}():`);
    
    try {
      let resultado;
      
      switch (nombreFuncion) {
        case 'getEstadisticasRapidas':
          resultado = getEstadisticasRapidas();
          break;
        case 'getListaLideres':
          resultado = getListaLideres();
          break;
        case 'getDashboardData':
          resultado = getDashboardData();
          break;
        default:
          console.log(`  ‚ö†Ô∏è Funci√≥n ${nombreFuncion} no reconocida`);
          return; // ‚úÖ CORRECCI√ìN: return en lugar de continue
      }
      
      if (resultado === null) {
        console.log(`  ‚ùå ${nombreFuncion}() retorn√≥ NULL`);
        resultados.errores.push(`${nombreFuncion}() retorna null`);
        resultados.funciones[nombreFuncion] = { estado: 'NULL', error: 'Retorna null' };
        resultados.exito = false;
      } else if (resultado && typeof resultado === 'object') {
        if (resultado.success === undefined) {
          console.log(`  ‚ö†Ô∏è ${nombreFuncion}() no tiene propiedad 'success'`);
          console.log(`  üìä Estructura: ${JSON.stringify(resultado).substring(0, 100)}...`);
          resultados.errores.push(`${nombreFuncion}() no tiene propiedad 'success'`);
          resultados.funciones[nombreFuncion] = { estado: 'SIN_SUCCESS', estructura: Object.keys(resultado) };
        } else if (resultado.success === false) {
          console.log(`  ‚ùå ${nombreFuncion}() retorn√≥ success: false`);
          console.log(`  üìä Error: ${resultado.error || 'Sin mensaje de error'}`);
          resultados.errores.push(`${nombreFuncion}() fall√≥: ${resultado.error || 'Sin mensaje'}`);
          resultados.funciones[nombreFuncion] = { estado: 'FALLO', error: resultado.error };
          resultados.exito = false;
        } else {
          console.log(`  ‚úÖ ${nombreFuncion}() funcion√≥ correctamente`);
          console.log(`  üìä Success: ${resultado.success}`);
          resultados.funciones[nombreFuncion] = { estado: 'OK', success: resultado.success };
        }
      } else {
        console.log(`  ‚ö†Ô∏è ${nombreFuncion}() retorn√≥ tipo inesperado: ${typeof resultado}`);
        console.log(`  üìä Valor: ${JSON.stringify(resultado).substring(0, 100)}...`);
        resultados.errores.push(`${nombreFuncion}() retorna tipo inesperado: ${typeof resultado}`);
        resultados.funciones[nombreFuncion] = { estado: 'TIPO_INESPERADO', tipo: typeof resultado };
        resultados.exito = false;
      }
      
    } catch (error) {
      console.log(`  ‚ùå ${nombreFuncion}() lanz√≥ excepci√≥n: ${error.toString()}`);
      resultados.errores.push(`${nombreFuncion}() excepci√≥n: ${error.toString()}`);
      resultados.funciones[nombreFuncion] = { estado: 'EXCEPCION', error: error.toString() };
      resultados.exito = false;
    }
  });
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // DIAGN√ìSTICO ADICIONAL: Verificar cach√©
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  console.log('\nüìã Verificando estado del cach√©...');
  
  try {
    const cache = CacheService.getScriptCache();
    const cacheKeys = ['STATS_DIRECT_V2', 'DASHBOARD_CONSOLIDATED_V1', 'UNIFIED_DASHBOARD_V3'];
    
    cacheKeys.forEach(key => {
      const valor = cache.get(key);
      if (valor) {
        console.log(`  ‚úÖ Cach√© ${key}: Datos encontrados (${valor.length} caracteres)`);
      } else {
        console.log(`  ‚ùå Cach√© ${key}: Vac√≠o`);
      }
    });
  } catch (cacheError) {
    console.log(`  ‚ùå Error verificando cach√©: ${cacheError.toString()}`);
    resultados.errores.push(`Error de cach√©: ${cacheError.toString()}`);
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // RESUMEN Y RECOMENDACIONES
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  console.log('\n' + '='.repeat(60));
  console.log('üìä RESUMEN DEL DIAGN√ìSTICO');
  console.log('='.repeat(60));
  
  console.log('\nüîç Estado de las funciones:');
  Object.keys(resultados.funciones).forEach(funcion => {
    const estado = resultados.funciones[funcion];
    const icono = estado.estado === 'OK' ? '‚úÖ' : '‚ùå';
    console.log(`  ${icono} ${funcion}: ${estado.estado}`);
    if (estado.error) {
      console.log(`      Error: ${estado.error}`);
    }
  });
  
  if (resultados.errores.length > 0) {
    console.log('\n‚ùå ERRORES ENCONTRADOS:');
    resultados.errores.forEach((error, index) => {
      console.log(`  ${index + 1}. ${error}`);
    });
  }
  
  if (resultados.exito) {
    console.log('\n‚úÖ DIAGN√ìSTICO COMPLETADO - No se encontraron problemas cr√≠ticos');
    console.log('üí° El error puede ser temporal o relacionado con el cach√©');
  } else {
    console.log('\n‚ö†Ô∏è DIAGN√ìSTICO COMPLETADO - Se encontraron problemas');
    console.log('üîß Se requieren correcciones antes de que el dashboard funcione');
  }
  
  // Recomendaciones espec√≠ficas
  console.log('\nüîß RECOMENDACIONES:');
  if (resultados.errores.some(e => e.includes('retorna null'))) {
    console.log('  1. Limpiar cach√©: clearCache()');
    console.log('  2. Verificar que las hojas de datos existan');
    console.log('  3. Ejecutar poblarResumenDashboard() si es necesario');
  }
  if (resultados.errores.some(e => e.includes('excepci√≥n'))) {
    console.log('  1. Revisar logs de error en Google Apps Script');
    console.log('  2. Verificar permisos de las hojas');
    console.log('  3. Comprobar que CONFIG.SHEETS.DIRECTORIO sea correcto');
  }
  
  return resultados;
}

/**
 * Correcci√≥n r√°pida para el error "Cannot read properties of null"
 * Intenta resolver los problemas m√°s comunes
 */
function corregirErrorNull() {
  console.log('üîß CORRECCI√ìN R√ÅPIDA: Error "Cannot read properties of null"');
  console.log('='.repeat(60));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    pasos: [],
    exito: true
  };
  
  try {
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PASO 1: Limpiar cach√© completamente
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\nüìã PASO 1: Limpiando cach√©...');
    
    try {
      clearCache();
      console.log('‚úÖ Cach√© limpiado exitosamente');
      resultados.pasos.push('Cach√© limpiado');
    } catch (error) {
      console.error('‚ùå Error limpiando cach√©:', error);
      resultados.pasos.push(`Error limpiando cach√©: ${error.toString()}`);
      resultados.exito = false;
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PASO 2: Verificar y poblar _ResumenDashboard
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\nüìã PASO 2: Verificando _ResumenDashboard...');
    
    try {
      const ss = SpreadsheetApp.openById(CONFIG.SHEETS.DIRECTORIO);
      let resumenSheet = ss.getSheetByName('_ResumenDashboard');
      
      if (!resumenSheet) {
        console.log('üìù Creando hoja _ResumenDashboard...');
        resumenSheet = ss.insertSheet('_ResumenDashboard');
        resultados.pasos.push('Hoja _ResumenDashboard creada');
      }
      
      // Verificar si tiene datos
      const lastRow = resumenSheet.getLastRow();
      if (lastRow < 2) {
        console.log('üìä Poblando hoja _ResumenDashboard...');
        const poblado = poblarResumenDashboard();
        if (poblado.success) {
          console.log('‚úÖ Hoja poblada exitosamente');
          resultados.pasos.push('Hoja _ResumenDashboard poblada');
        } else {
          console.error('‚ùå Error poblando hoja:', poblado.error);
          resultados.pasos.push(`Error poblando hoja: ${poblado.error}`);
          resultados.exito = false;
        }
      } else {
        console.log('‚úÖ Hoja _ResumenDashboard ya tiene datos');
        resultados.pasos.push('Hoja _ResumenDashboard verificada');
      }
    } catch (error) {
      console.error('‚ùå Error verificando _ResumenDashboard:', error);
      resultados.pasos.push(`Error verificando hoja: ${error.toString()}`);
      resultados.exito = false;
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PASO 3: Probar funciones individualmente
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\nüìã PASO 3: Probando funciones...');
    
    const funciones = [
      { nombre: 'getEstadisticasRapidas', fn: getEstadisticasRapidas },
      { nombre: 'getListaLideres', fn: getListaLideres },
      { nombre: 'getDashboardData', fn: getDashboardData }
    ];
    
    funciones.forEach(({ nombre, fn }) => {
      try {
        console.log(`  Probando ${nombre}()...`);
        const resultado = fn();
        
        if (resultado === null) {
          console.log(`  ‚ùå ${nombre}() retorna null`);
          resultados.pasos.push(`${nombre}() retorna null`);
          resultados.exito = false;
        } else if (resultado && typeof resultado === 'object' && resultado.success !== undefined) {
          console.log(`  ‚úÖ ${nombre}() OK - success: ${resultado.success}`);
          resultados.pasos.push(`${nombre}() funcionando`);
        } else {
          console.log(`  ‚ö†Ô∏è ${nombre}() estructura inesperada`);
          resultados.pasos.push(`${nombre}() estructura inesperada`);
        }
      } catch (error) {
        console.log(`  ‚ùå ${nombre}() error: ${error.toString()}`);
        resultados.pasos.push(`${nombre}() error: ${error.toString()}`);
        resultados.exito = false;
      }
    });
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PASO 4: Forzar recarga de cach√©
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\nüìã PASO 4: Forzando recarga de cach√©...');
    
    try {
      // Llamar a cada funci√≥n para poblar el cach√©
      getEstadisticasRapidas();
      getListaLideres();
      getDashboardData();
      
      console.log('‚úÖ Cach√© recargado exitosamente');
      resultados.pasos.push('Cach√© recargado');
    } catch (error) {
      console.error('‚ùå Error recargando cach√©:', error);
      resultados.pasos.push(`Error recargando cach√©: ${error.toString()}`);
      resultados.exito = false;
    }
    
  } catch (error) {
    console.error('‚ùå Error cr√≠tico en correcci√≥n:', error);
    resultados.pasos.push(`Error cr√≠tico: ${error.toString()}`);
    resultados.exito = false;
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // RESUMEN
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  console.log('\n' + '='.repeat(60));
  console.log('üìä RESUMEN DE CORRECCI√ìN');
  console.log('='.repeat(60));
  
  console.log('\nüîß Pasos ejecutados:');
  resultados.pasos.forEach((paso, index) => {
    const icono = paso.includes('Error') || paso.includes('null') ? '‚ùå' : '‚úÖ';
    console.log(`  ${index + 1}. ${icono} ${paso}`);
  });
  
  if (resultados.exito) {
    console.log('\nüéâ ¬°CORRECCI√ìN COMPLETADA!');
    console.log('‚úÖ El dashboard deber√≠a funcionar correctamente ahora');
    console.log('üîÑ Recarga el dashboard para verificar');
  } else {
    console.log('\n‚ö†Ô∏è CORRECCI√ìN COMPLETADA CON ERRORES');
    console.log('üîß Algunos problemas persisten - revisar logs anteriores');
  }
  
  return resultados;
}

/**
 * Test simple para verificar que no hay errores de sintaxis
 */
function testSintaxisCorrecta() {
  console.log('üß™ TEST: Verificaci√≥n de sintaxis');
  console.log('='.repeat(40));
  
  try {
    console.log('‚úÖ Archivo SistemaTestsRobusto.gs cargado sin errores de sintaxis');
    console.log('‚úÖ Todas las funciones est√°n disponibles');
    
    // Probar que las funciones principales existen
    const funciones = [
      'diagnosticarErrorNull',
      'corregirErrorNull', 
      'testPorcentajesCalculados',
      'testMetricasCorregidas',
      'poblarResumenDashboard'
    ];
    
    console.log('\nüìã Verificando funciones disponibles:');
    funciones.forEach(funcion => {
      if (typeof eval(funcion) === 'function') {
        console.log(`  ‚úÖ ${funcion}() - Disponible`);
      } else {
        console.log(`  ‚ùå ${funcion}() - No encontrada`);
      }
    });
    
    console.log('\nüéâ ¬°Sistema de pruebas listo para usar!');
    console.log('üí° Ejecuta diagnosticarErrorNull() para diagnosticar el problema del dashboard');
    
    return {
      success: true,
      message: 'Sintaxis correcta, sistema listo',
      timestamp: new Date().toISOString()
    };
    
  } catch (error) {
    console.error('‚ùå Error de sintaxis encontrado:', error);
    return {
      success: false,
      error: error.toString(),
      timestamp: new Date().toISOString()
    };
  }
}

/**
 * Test simple para verificar que los porcentajes se calculan correctamente
 */
function testPorcentajesDinamicos() {
  console.log('üß™ TEST: Porcentajes calculados din√°micamente');
  console.log('='.repeat(50));
  
  try {
    // Limpiar cach√© para forzar recarga
    clearCache();
    
    // Obtener estad√≠sticas
    const stats = getEstadisticasRapidas();
    
    if (stats.success && stats.data) {
      const actividad = stats.data.actividad;
      const metricas = stats.data.metricas;
      
      console.log('üìä Datos desde hoja:');
      console.log(`  Total Recibiendo: ${actividad.total_recibiendo_celulas}`);
      console.log(`  Activos: ${actividad.activos_recibiendo_celula}`);
      console.log(`  Alerta: ${actividad.alerta_2_3_semanas}`);
      console.log(`  Cr√≠tico: ${actividad.critico_mas_1_mes}`);
      
      console.log('\nüìä Porcentajes calculados:');
      console.log(`  Activos: ${metricas.porcentaje_activos}%`);
      console.log(`  Alerta: ${metricas.porcentaje_alerta}%`);
      console.log(`  Cr√≠tico: ${metricas.porcentaje_critico}%`);
      
      // Verificar que los porcentajes no son cero
      const porcentajesNoCero = 
        parseFloat(metricas.porcentaje_activos) > 0 ||
        parseFloat(metricas.porcentaje_alerta) > 0 ||
        parseFloat(metricas.porcentaje_critico) > 0;
      
      if (porcentajesNoCero) {
        console.log('\n‚úÖ Porcentajes calculados correctamente');
        console.log('üí° Los porcentajes se calculan din√°micamente desde los datos de la hoja');
        return true;
      } else {
        console.log('\n‚ö†Ô∏è Todos los porcentajes son cero');
        console.log('üí° Esto puede ser normal si no hay datos en la hoja');
        return true;
      }
      
    } else {
      console.error('‚ùå Error obteniendo estad√≠sticas');
      return false;
    }
    
  } catch (error) {
    console.error('‚ùå Error en test:', error);
    return false;
  }
}

/**
 * Diagn√≥stico espec√≠fico para el error "Cannot read properties of null"
 * Verifica cada funci√≥n que se llama en paralelo en el dashboard
 */
function diagnosticarErrorNull() {
  console.log('üîç DIAGN√ìSTICO: Error "Cannot read properties of null"');
  console.log('='.repeat(60));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    funciones: {},
    exito: true
  };
  
  // Lista de funciones que se llaman en paralelo en el dashboard
  const funcionesParaProbar = [
    'getEstadisticasRapidas',
    'getDashboardData', 
    'getDirectorioCompleto',
    'getLideresActivos',
    'getCelulasActivas',
    'getIngresosRecientes'
  ];
  
  console.log('üß™ Probando cada funci√≥n individualmente...\n');
  
  funcionesParaProbar.forEach(nombreFuncion => {
    console.log(`üìã Probando: ${nombreFuncion}`);
    
    try {
      let resultado = null;
      
      // Ejecutar funci√≥n seg√∫n su nombre
      switch(nombreFuncion) {
        case 'getEstadisticasRapidas':
          resultado = getEstadisticasRapidas();
          break;
        case 'getDashboardData':
          resultado = getDashboardData();
          break;
        case 'getDirectorioCompleto':
          resultado = getDirectorioCompleto();
          break;
        case 'getLideresActivos':
          resultado = getLideresActivos();
          break;
        case 'getCelulasActivas':
          resultado = getCelulasActivas();
          break;
        case 'getIngresosRecientes':
          resultado = getIngresosRecientes();
          break;
        default:
          console.log(`  ‚ö†Ô∏è Funci√≥n ${nombreFuncion} no reconocida`);
          return;
      }
      
      // Verificar resultado
      if (resultado === null) {
        console.log(`  ‚ùå ${nombreFuncion} devuelve NULL`);
        resultados.funciones[nombreFuncion] = { estado: 'NULL', error: 'Funci√≥n devuelve null' };
        resultados.exito = false;
      } else if (typeof resultado === 'object' && resultado.hasOwnProperty('success')) {
        console.log(`  ‚úÖ ${nombreFuncion} devuelve objeto con 'success': ${resultado.success}`);
        resultados.funciones[nombreFuncion] = { estado: 'OK', success: resultado.success };
      } else if (typeof resultado === 'object') {
        console.log(`  ‚ö†Ô∏è ${nombreFuncion} devuelve objeto sin 'success'`);
        console.log(`     Propiedades: ${Object.keys(resultado).join(', ')}`);
        resultados.funciones[nombreFuncion] = { estado: 'SIN_SUCCESS', propiedades: Object.keys(resultado) };
      } else {
        console.log(`  ‚ö†Ô∏è ${nombreFuncion} devuelve: ${typeof resultado}`);
        resultados.funciones[nombreFuncion] = { estado: 'TIPO_INESPERADO', tipo: typeof resultado };
      }
      
    } catch (error) {
      console.log(`  ‚ùå ${nombreFuncion} ERROR: ${error.message}`);
      resultados.funciones[nombreFuncion] = { estado: 'ERROR', error: error.message };
      resultados.exito = false;
    }
    
    console.log(''); // L√≠nea en blanco
  });
  
  // Resumen
  console.log('='.repeat(60));
  console.log('üìä RESUMEN DEL DIAGN√ìSTICO');
  console.log('='.repeat(60));
  
  Object.keys(resultados.funciones).forEach(funcion => {
    const info = resultados.funciones[funcion];
    const icono = info.estado === 'OK' ? '‚úÖ' : 
                 info.estado === 'NULL' ? '‚ùå' : '‚ö†Ô∏è';
    console.log(`${icono} ${funcion}: ${info.estado}`);
  });
  
  if (resultados.exito) {
    console.log('\nüéâ Todas las funciones devuelven objetos v√°lidos');
  } else {
    console.log('\n‚ö†Ô∏è Algunas funciones tienen problemas');
    console.log('üí° Revisar las funciones marcadas con ‚ùå o ‚ö†Ô∏è');
  }
  
  return resultados;
}

/**
 * Correcci√≥n r√°pida para el error "Cannot read properties of null"
 * Intenta resolver los problemas m√°s comunes
 */
function corregirErrorNull() {
  console.log('üîß CORRECCI√ìN R√ÅPIDA: Error "Cannot read properties of null"');
  console.log('='.repeat(60));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    correcciones: {},
    exito: true
  };
  
  try {
    // 1. Limpiar cach√© completamente
    console.log('üßπ Paso 1: Limpiando cach√©...');
    clearCache();
    resultados.correcciones.cache_limpiado = true;
    
    // 2. Verificar que _ResumenDashboard existe
    console.log('üìã Paso 2: Verificando hoja _ResumenDashboard...');
    try {
      const ss = SpreadsheetApp.openById(CONFIG.SHEETS.DIRECTORIO);
      const resumenSheet = ss.getSheetByName('_ResumenDashboard');
      
      if (!resumenSheet) {
        console.log('‚ùå Hoja _ResumenDashboard no existe');
        resultados.correcciones.hoja_resumen = false;
        resultados.exito = false;
      } else {
        console.log('‚úÖ Hoja _ResumenDashboard existe');
        resultados.correcciones.hoja_resumen = true;
      }
    } catch (error) {
      console.log(`‚ùå Error verificando hoja: ${error.message}`);
      resultados.correcciones.hoja_resumen = false;
      resultados.exito = false;
    }
    
    // 3. Probar getEstadisticasRapidas espec√≠ficamente
    console.log('üìä Paso 3: Probando getEstadisticasRapidas...');
    try {
      const stats = getEstadisticasRapidas();
      if (stats && stats.success) {
        console.log('‚úÖ getEstadisticasRapidas funciona correctamente');
        resultados.correcciones.getEstadisticasRapidas = true;
      } else {
        console.log('‚ùå getEstadisticasRapidas no funciona correctamente');
        console.log('Resultado:', stats);
        resultados.correcciones.getEstadisticasRapidas = false;
        resultados.exito = false;
      }
    } catch (error) {
      console.log(`‚ùå Error en getEstadisticasRapidas: ${error.message}`);
      resultados.correcciones.getEstadisticasRapidas = false;
      resultados.exito = false;
    }
    
    // 4. Probar getDashboardData espec√≠ficamente
    console.log('üè† Paso 4: Probando getDashboardData...');
    try {
      const dashboard = getDashboardData();
      if (dashboard && dashboard.success) {
        console.log('‚úÖ getDashboardData funciona correctamente');
        resultados.correcciones.getDashboardData = true;
      } else {
        console.log('‚ùå getDashboardData no funciona correctamente');
        console.log('Resultado:', dashboard);
        resultados.correcciones.getDashboardData = false;
        resultados.exito = false;
      }
    } catch (error) {
      console.log(`‚ùå Error en getDashboardData: ${error.message}`);
      resultados.correcciones.getDashboardData = false;
      resultados.exito = false;
    }
    
  } catch (error) {
    console.error('‚ùå Error cr√≠tico en correcci√≥n:', error);
    resultados.exito = false;
  }
  
  // Resumen
  console.log('\n' + '='.repeat(60));
  console.log('üìä RESUMEN DE CORRECCIONES');
  console.log('='.repeat(60));
  
  Object.keys(resultados.correcciones).forEach(correccion => {
    const estado = resultados.correcciones[correccion];
    const icono = estado ? '‚úÖ' : '‚ùå';
    console.log(`${icono} ${correccion}: ${estado ? 'OK' : 'FALLO'}`);
  });
  
  if (resultados.exito) {
    console.log('\nüéâ Correcci√≥n exitosa');
    console.log('üí° Recarga el dashboard para ver si el error se resolvi√≥');
  } else {
    console.log('\n‚ö†Ô∏è Algunas correcciones fallaron');
    console.log('üí° Revisar logs anteriores para detalles');
  }
  
  return resultados;
}

/**
 * Test espec√≠fico para verificar correcciones de m√©tricas
 * Verifica que lideres_inactivos se incluye y que los valores no son cero
 */
function testCorreccionesMetricas() {
  console.log('üß™ TEST: Verificando correcciones de m√©tricas');
  console.log('='.repeat(60));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    tests: {},
    exito: true
  };
  
  try {
    // Limpiar cach√© para forzar recarga
    clearCache();
    
    // Obtener estad√≠sticas
    const stats = getEstadisticasRapidas();
    
    if (stats.success && stats.data) {
      const actividad = stats.data.actividad;
      const metricas = stats.data.metricas;
      
      console.log('üìä Verificando estructura de datos:');
      console.log('  actividad:', Object.keys(actividad));
      console.log('  metricas:', Object.keys(metricas));
      
      // Test 1: Verificar que lideres_inactivos existe
      const tieneLideresInactivos = actividad.hasOwnProperty('lideres_inactivos');
      console.log(`\n‚úÖ Test 1 - lideres_inactivos existe: ${tieneLideresInactivos ? 'PASS' : 'FAIL'}`);
      resultados.tests.lideres_inactivos_existe = tieneLideresInactivos;
      
      if (!tieneLideresInactivos) {
        resultados.exito = false;
      }
      
      // Test 2: Verificar que los valores no son todos cero
      const valoresActividad = Object.values(actividad);
      const valoresMetricas = Object.values(metricas);
      const todosValores = [...valoresActividad, ...valoresMetricas];
      
      const hayValoresNoCero = todosValores.some(valor => 
        typeof valor === 'number' && valor > 0
      );
      
      console.log(`\n‚úÖ Test 2 - Hay valores no cero: ${hayValoresNoCero ? 'PASS' : 'FAIL'}`);
      console.log('  Valores de actividad:', valoresActividad);
      console.log('  Valores de m√©tricas:', valoresMetricas);
      resultados.tests.hay_valores_no_cero = hayValoresNoCero;
      
      if (!hayValoresNoCero) {
        console.log('‚ö†Ô∏è Todos los valores son cero - verificar hoja _ResumenDashboard');
        resultados.exito = false;
      }
      
      // Test 3: Verificar estructura espec√≠fica
      const estructuraCorrecta = 
        actividad.hasOwnProperty('total_recibiendo_celulas') &&
        actividad.hasOwnProperty('activos_recibiendo_celula') &&
        actividad.hasOwnProperty('alerta_2_3_semanas') &&
        actividad.hasOwnProperty('critico_mas_1_mes') &&
        actividad.hasOwnProperty('lideres_inactivos') &&
        metricas.hasOwnProperty('porcentaje_activos') &&
        metricas.hasOwnProperty('porcentaje_alerta') &&
        metricas.hasOwnProperty('porcentaje_critico');
      
      console.log(`\n‚úÖ Test 3 - Estructura correcta: ${estructuraCorrecta ? 'PASS' : 'FAIL'}`);
      resultados.tests.estructura_correcta = estructuraCorrecta;
      
      if (!estructuraCorrecta) {
        resultados.exito = false;
      }
      
      // Test 4: Verificar c√°lculos de porcentajes
      const totalRecibiendo = actividad.total_recibiendo_celulas;
      if (totalRecibiendo > 0) {
        const porcentajeActivosCalculado = ((actividad.activos_recibiendo_celula / totalRecibiendo) * 100).toFixed(1);
        const porcentajeActivosCorrecto = metricas.porcentaje_activos == porcentajeActivosCalculado;
        
        console.log(`\n‚úÖ Test 4 - Porcentajes correctos: ${porcentajeActivosCorrecto ? 'PASS' : 'FAIL'}`);
        console.log(`  Calculado: ${porcentajeActivosCalculado}%, Encontrado: ${metricas.porcentaje_activos}%`);
        resultados.tests.porcentajes_correctos = porcentajeActivosCorrecto;
        
        if (!porcentajeActivosCorrecto) {
          resultados.exito = false;
        }
      } else {
        console.log('\n‚ö†Ô∏è Test 4 - No se puede verificar porcentajes (total = 0)');
        resultados.tests.porcentajes_correctos = true; // No es un error
      }
      
    } else {
      console.error('‚ùå Error obteniendo estad√≠sticas');
      resultados.tests.estadisticas_ok = false;
      resultados.exito = false;
    }
    
  } catch (error) {
    console.error('‚ùå Error cr√≠tico en test:', error);
    resultados.exito = false;
  }
  
  // Resumen
  console.log('\n' + '='.repeat(60));
  console.log('üìä RESUMEN DE TESTS');
  console.log('='.repeat(60));
  
  Object.keys(resultados.tests).forEach(test => {
    const resultado = resultados.tests[test];
    const icono = resultado ? '‚úÖ' : '‚ùå';
    console.log(`${icono} ${test}: ${resultado ? 'PASS' : 'FAIL'}`);
  });
  
  if (resultados.exito) {
    console.log('\nüéâ ¬°TODAS LAS CORRECCIONES FUNCIONAN!');
    console.log('‚úÖ lideres_inactivos incluido correctamente');
    console.log('‚úÖ Valores no son todos cero');
    console.log('‚úÖ Estructura de datos correcta');
    console.log('‚úÖ Porcentajes calculados correctamente');
    console.log('üîÑ Recarga el dashboard para ver los cambios');
  } else {
    console.log('\n‚ö†Ô∏è ALGUNAS CORRECCIONES FALLARON');
    console.log('üí° Revisar logs anteriores para detalles');
    console.log('üí° Verificar que la hoja _ResumenDashboard tenga datos');
  }
  
  return resultados;
}

/**
 * Test espec√≠fico para verificar la nueva regla de "LCF Hibernando"
 * Verifica que la regla cambi√≥ de > 14 d√≠as a > 19 d√≠as
 */
function testLCFHibernando() {
  console.log('üß™ TEST: Verificando nueva regla LCF Hibernando');
  console.log('='.repeat(60));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    tests: {},
    exito: true
  };
  
  try {
    // Simular datos de equipo con diferentes d√≠as de inactividad
    const equipoSimulado = [
      { Dias_Inactivo: 5, IDP: 10, Perfil_Lider: 'Activo' },      // Activo
      { Dias_Inactivo: 15, IDP: 8, Perfil_Lider: 'Activo' },      // Inactivo (vieja regla) pero Activo (nueva regla)
      { Dias_Inactivo: 20, IDP: 5, Perfil_Lider: 'Activo' },      // Hibernando (nueva regla)
      { Dias_Inactivo: 25, IDP: 3, Perfil_Lider: 'Activo' },      // Hibernando (nueva regla)
      { Dias_Inactivo: null, IDP: 0, Perfil_Lider: 'Activo' },    // Hibernando (IDP = 0)
      { Dias_Inactivo: 10, IDP: 12, Perfil_Lider: 'INACTIVO' },   // Hibernando (Perfil incluye INACTIVO)
      { Dias_Inactivo: 18, IDP: 7, Perfil_Lider: 'Activo' },      // Activo (cerca del l√≠mite)
      { Dias_Inactivo: 19, IDP: 6, Perfil_Lider: 'Activo' },      // Activo (l√≠mite exacto)
      { Dias_Inactivo: 20, IDP: 4, Perfil_Lider: 'Activo' },      // Hibernando (l√≠mite + 1)
    ];
    
    console.log('üìä Datos de prueba:');
    equipoSimulado.forEach((lcf, i) => {
      console.log(`  LCF ${i + 1}: ${lcf.Dias_Inactivo} d√≠as, IDP: ${lcf.IDP}, Perfil: ${lcf.Perfil_Lider}`);
    });
    
    // Aplicar la nueva regla: > 19 d√≠as O IDP = 0 O Perfil incluye 'INACTIVO'
    const hibernando = equipoSimulado.filter(lcf => 
      (lcf.Dias_Inactivo !== null && lcf.Dias_Inactivo > 19) || 
      (lcf.IDP === 0 || lcf.Perfil_Lider?.includes('INACTIVO'))
    );
    
    console.log(`\nüîç Aplicando nueva regla (Dias_Inactivo > 19):`);
    hibernando.forEach((lcf, i) => {
      const razon = lcf.Dias_Inactivo > 19 ? `D√≠as: ${lcf.Dias_Inactivo}` :
                   lcf.IDP === 0 ? 'IDP = 0' :
                   lcf.Perfil_Lider?.includes('INACTIVO') ? 'Perfil INACTIVO' : 'Otra raz√≥n';
      console.log(`  LCF Hibernando ${i + 1}: ${razon}`);
    });
    
    const totalHibernando = hibernando.length;
    console.log(`\nüìä Total LCF Hibernando: ${totalHibernando}`);
    
    // Test 1: Verificar que la regla funciona correctamente
    const esperadoHibernando = 4; // Deber√≠an ser 4: d√≠as 20, 25, IDP=0, Perfil INACTIVO
    const reglaCorrecta = totalHibernando === esperadoHibernando;
    
    console.log(`\n‚úÖ Test 1 - Regla correcta: ${reglaCorrecta ? 'PASS' : 'FAIL'}`);
    console.log(`  Esperado: ${esperadoHibernando}, Obtenido: ${totalHibernando}`);
    resultados.tests.regla_correcta = reglaCorrecta;
    
    if (!reglaCorrecta) {
      resultados.exito = false;
    }
    
    // Test 2: Verificar que LCF con 15-19 d√≠as NO se consideran hibernando
    const lcfEntre15y19 = equipoSimulado.filter(lcf => 
      lcf.Dias_Inactivo !== null && 
      lcf.Dias_Inactivo >= 15 && 
      lcf.Dias_Inactivo <= 19 &&
      lcf.IDP !== 0 &&
      !lcf.Perfil_Lider?.includes('INACTIVO')
    );
    
    const noHibernandoCorrecto = lcfEntre15y19.length === 2; // Deber√≠an ser 2: d√≠as 15 y 18
    
    console.log(`\n‚úÖ Test 2 - LCF 15-19 d√≠as no hibernando: ${noHibernandoCorrecto ? 'PASS' : 'FAIL'}`);
    console.log(`  LCF entre 15-19 d√≠as: ${lcfEntre15y19.length} (deber√≠an ser 2)`);
    resultados.tests.no_hibernando_15_19 = noHibernandoCorrecto;
    
    if (!noHibernandoCorrecto) {
      resultados.exito = false;
    }
    
    // Test 3: Verificar que LCF con IDP = 0 se consideran hibernando
    const lcfIDPCero = equipoSimulado.filter(lcf => lcf.IDP === 0);
    const idpCeroHibernando = lcfIDPCero.length > 0 && hibernando.some(lcf => lcf.IDP === 0);
    
    console.log(`\n‚úÖ Test 3 - LCF con IDP = 0 hibernando: ${idpCeroHibernando ? 'PASS' : 'FAIL'}`);
    console.log(`  LCF con IDP = 0: ${lcfIDPCero.length}, Incluidos en hibernando: ${idpCeroHibernando}`);
    resultados.tests.idp_cero_hibernando = idpCeroHibernando;
    
    if (!idpCeroHibernando) {
      resultados.exito = false;
    }
    
  } catch (error) {
    console.error('‚ùå Error cr√≠tico en test:', error);
    resultados.exito = false;
  }
  
  // Resumen
  console.log('\n' + '='.repeat(60));
  console.log('üìä RESUMEN DE TESTS');
  console.log('='.repeat(60));
  
  Object.keys(resultados.tests).forEach(test => {
    const resultado = resultados.tests[test];
    const icono = resultado ? '‚úÖ' : '‚ùå';
    console.log(`${icono} ${test}: ${resultado ? 'PASS' : 'FAIL'}`);
  });
  
  if (resultados.exito) {
    console.log('\nüéâ ¬°NUEVA REGLA FUNCIONA CORRECTAMENTE!');
    console.log('‚úÖ LCF Hibernando: > 19 d√≠as O IDP = 0 O Perfil INACTIVO');
    console.log('‚úÖ LCF con 15-19 d√≠as ya NO se consideran hibernando');
    console.log('‚úÖ El dashboard mostrar√° menos LCF en estado cr√≠tico');
  } else {
    console.log('\n‚ö†Ô∏è ALGUNOS TESTS FALLARON');
    console.log('üí° Revisar logs anteriores para detalles');
  }
  
  return resultados;
}

/**
 * Analiza la hoja _ResumenDashboard para identificar las 8 m√©tricas nuevas
 * y propone una organizaci√≥n en 2 filas de 4 m√©tricas cada una
 */
function analizarResumenDashboard() {
  console.log('üîç AN√ÅLISIS: Hoja _ResumenDashboard con 8 m√©tricas nuevas');
  console.log('='.repeat(70));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    metricas_encontradas: {},
    organizacion_propuesta: {},
    exito: true
  };
  
  try {
    // Leer la hoja _ResumenDashboard
    const ss = SpreadsheetApp.openById(CONFIG.SHEETS.DIRECTORIO);
    const resumenSheet = ss.getSheetByName('_ResumenDashboard');
    
    if (!resumenSheet) {
      console.error('‚ùå Hoja _ResumenDashboard no encontrada');
      resultados.exito = false;
      return resultados;
    }
    
    // Leer un rango amplio para capturar todas las m√©tricas
    const valores = resumenSheet.getRange('A1:B30').getValues();
    
    console.log('üìä M√©tricas encontradas en _ResumenDashboard:');
    console.log('='.repeat(50));
    
    const metricas = {};
    valores.forEach((row, index) => {
      if (row[0] && row[0].toString().trim()) {
        const nombre = row[0].toString().trim();
        const valor = row[1] || 0;
        metricas[nombre] = valor;
        
        console.log(`${String(index + 1).padStart(2, '0')}. ${nombre}: ${valor}`);
      }
    });
    
    resultados.metricas_encontradas = metricas;
    
    // Identificar m√©tricas existentes vs nuevas
    const metricasExistentes = [
      'Total Recibiendo',
      'Activos', 
      'Alerta',
      'Cr√≠tico',
      'Total L√≠deres',
      'Total C√©lulas',
      'Total Ingresos',
      'Tasa Integraci√≥n',
      'L√≠deres Inactivos'
    ];
    
    const metricasNuevas = Object.keys(metricas).filter(nombre => 
      !metricasExistentes.includes(nombre)
    );
    
    console.log('\nüÜï M√âTRICAS NUEVAS IDENTIFICADAS:');
    console.log('='.repeat(40));
    metricasNuevas.forEach((nombre, index) => {
      console.log(`${index + 1}. ${nombre}: ${metricas[nombre]}`);
    });
    
    // Proponer organizaci√≥n en 2 filas de 4 m√©tricas
    console.log('\nüìã ORGANIZACI√ìN PROPUESTA:');
    console.log('='.repeat(50));
    
    // Fila 1: M√©tricas principales (4 m√©tricas)
    const fila1 = [
      'Total Recibiendo',
      'Activos',
      'Alerta', 
      'Cr√≠tico'
    ];
    
    // Fila 2: M√©tricas secundarias (4 m√©tricas)
    const fila2 = [
      'Total L√≠deres',
      'Total C√©lulas', 
      'Total Ingresos',
      'Tasa Integraci√≥n'
    ];
    
    // Si hay m√°s de 8 m√©tricas, agregar las nuevas
    const todasLasMetricas = [...fila1, ...fila2, ...metricasNuevas];
    
    console.log('üèÜ FILA 1 - M√©tricas Principales:');
    fila1.forEach((nombre, index) => {
      const valor = metricas[nombre] || 0;
      console.log(`  ${index + 1}. ${nombre}: ${valor}`);
    });
    
    console.log('\nüìä FILA 2 - M√©tricas Secundarias:');
    fila2.forEach((nombre, index) => {
      const valor = metricas[nombre] || 0;
      console.log(`  ${index + 1}. ${nombre}: ${valor}`);
    });
    
    if (metricasNuevas.length > 0) {
      console.log('\nüÜï FILA 3 - M√©tricas Nuevas (si es necesario):');
      metricasNuevas.forEach((nombre, index) => {
        const valor = metricas[nombre] || 0;
        console.log(`  ${index + 1}. ${nombre}: ${valor}`);
      });
    }
    
    // Proponer estructura HTML
    console.log('\nüíª ESTRUCTURA HTML PROPUESTA:');
    console.log('='.repeat(50));
    
    console.log(`
<!-- FILA 1: M√©tricas Principales -->
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
    <div class="stat-card">
        <div class="flex items-center justify-between">
            <div>
                <p class="text-gray-500 text-sm">Total Recibiendo C√©lulas</p>
                <p class="text-3xl font-bold text-gray-800">\${actividad.total_recibiendo_celulas || 0}</p>
            </div>
            <i class="fas fa-users text-blue-500 text-3xl"></i>
        </div>
    </div>
    
    <div class="stat-card">
        <div class="flex items-center justify-between">
            <div>
                <p class="text-gray-500 text-sm">Activos Recibiendo C√©lula</p>
                <p class="text-3xl font-bold text-green-600">\${actividad.activos_recibiendo_celula || 0}</p>
                <p class="text-xs text-green-600">\${metricas.porcentaje_activos || 0}% del total</p>
            </div>
            <i class="fas fa-check-circle text-green-500 text-3xl"></i>
        </div>
    </div>
    
    <div class="stat-card">
        <div class="flex items-center justify-between">
            <div>
                <p class="text-gray-500 text-sm">Alerta (2-3 semanas)</p>
                <p class="text-3xl font-bold text-yellow-600">\${actividad.alerta_2_3_semanas || 0}</p>
                <p class="text-xs text-yellow-600">\${metricas.porcentaje_alerta || 0}% del total</p>
            </div>
            <i class="fas fa-exclamation-triangle text-yellow-500 text-3xl"></i>
        </div>
    </div>
    
    <div class="stat-card">
        <div class="flex items-center justify-between">
            <div>
                <p class="text-gray-500 text-sm">Cr√≠tico (+1 mes)</p>
                <p class="text-3xl font-bold text-red-600">\${actividad.critico_mas_1_mes || 0}</p>
                <p class="text-xs text-red-600">\${metricas.porcentaje_critico || 0}% del total</p>
            </div>
            <i class="fas fa-exclamation-circle text-red-500 text-3xl"></i>
        </div>
    </div>
</div>

<!-- FILA 2: M√©tricas Secundarias -->
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
    <div class="stat-card">
        <div class="flex items-center justify-between">
            <div>
                <p class="text-gray-500 text-sm">Total L√≠deres</p>
                <p class="text-3xl font-bold text-blue-600">\${metricas.total_lideres || 0}</p>
            </div>
            <i class="fas fa-user-tie text-blue-500 text-3xl"></i>
        </div>
    </div>
    
    <div class="stat-card">
        <div class="flex items-center justify-between">
            <div>
                <p class="text-gray-500 text-sm">Total C√©lulas</p>
                <p class="text-3xl font-bold text-green-600">\${metricas.total_celulas || 0}</p>
            </div>
            <i class="fas fa-home text-green-500 text-3xl"></i>
        </div>
    </div>
    
    <div class="stat-card">
        <div class="flex items-center justify-between">
            <div>
                <p class="text-gray-500 text-sm">Total Ingresos</p>
                <p class="text-3xl font-bold text-purple-600">\${metricas.total_ingresos || 0}</p>
            </div>
            <i class="fas fa-chart-line text-purple-500 text-3xl"></i>
        </div>
    </div>
    
    <div class="stat-card">
        <div class="flex items-center justify-between">
            <div>
                <p class="text-gray-500 text-sm">Tasa Integraci√≥n</p>
                <p class="text-3xl font-bold text-indigo-600">\${metricas.tasa_integracion || 0}%</p>
            </div>
            <i class="fas fa-percentage text-indigo-500 text-3xl"></i>
        </div>
    </div>
</div>
    `);
    
    resultados.organizacion_propuesta = {
      fila1: fila1,
      fila2: fila2,
      metricas_nuevas: metricasNuevas,
      total_metricas: Object.keys(metricas).length
    };
    
    console.log('\n‚úÖ AN√ÅLISIS COMPLETADO');
    console.log(`üìä Total de m√©tricas encontradas: ${Object.keys(metricas).length}`);
    console.log(`üÜï M√©tricas nuevas: ${metricasNuevas.length}`);
    console.log('üí° Usar la estructura HTML propuesta para organizar las m√©tricas');
    
  } catch (error) {
    console.error('‚ùå Error analizando _ResumenDashboard:', error);
    resultados.exito = false;
  }
  
  return resultados;
}

/**
 * An√°lisis directo de la hoja _ResumenDashboard
 * Solo trabaja con la informaci√≥n actual en la hoja, sin asumir m√©tricas anteriores
 */
function analizarHojaActual() {
  console.log('üîç AN√ÅLISIS DIRECTO: Hoja _ResumenDashboard actual');
  console.log('='.repeat(70));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    metricas_actuales: {},
    organizacion_sugerida: {},
    exito: true
  };
  
  try {
    // Leer la hoja _ResumenDashboard
    const ss = SpreadsheetApp.openById(CONFIG.SHEETS.DIRECTORIO);
    const resumenSheet = ss.getSheetByName('_ResumenDashboard');
    
    if (!resumenSheet) {
      console.error('‚ùå Hoja _ResumenDashboard no encontrada');
      resultados.exito = false;
      return resultados;
    }
    
    // Leer un rango amplio para capturar todas las m√©tricas actuales
    const valores = resumenSheet.getRange('A1:B50').getValues();
    
    console.log('üìä M√âTRICAS ACTUALES EN LA HOJA:');
    console.log('='.repeat(50));
    
    const metricas = {};
    let contador = 0;
    
    valores.forEach((row, index) => {
      if (row[0] && row[0].toString().trim() && row[0].toString().trim() !== '') {
        const nombre = row[0].toString().trim();
        const valor = row[1] || 0;
        metricas[nombre] = valor;
        contador++;
        
        console.log(`${String(contador).padStart(2, '0')}. ${nombre}: ${valor}`);
      }
    });
    
    resultados.metricas_actuales = metricas;
    
    console.log(`\nüìà TOTAL DE M√âTRICAS ENCONTRADAS: ${contador}`);
    
    // Organizar en grupos l√≥gicos bas√°ndose en los nombres
    const metricasArray = Object.keys(metricas);
    
    // Identificar patrones en los nombres para agrupar
    const grupos = {
      actividad: [],
      lideres: [],
      celulas: [],
      ingresos: [],
      porcentajes: [],
      otros: []
    };
    
    metricasArray.forEach(nombre => {
      const nombreLower = nombre.toLowerCase();
      
      if (nombreLower.includes('activo') || nombreLower.includes('alerta') || 
          nombreLower.includes('cr√≠tico') || nombreLower.includes('recibiendo') ||
          nombreLower.includes('hibernando') || nombreLower.includes('inactivo')) {
        grupos.actividad.push(nombre);
      } else if (nombreLower.includes('l√≠der') || nombreLower.includes('ld') || 
                 nombreLower.includes('lcf') || nombreLower.includes('lm')) {
        grupos.lideres.push(nombre);
      } else if (nombreLower.includes('c√©lula') || nombreLower.includes('celula')) {
        grupos.celulas.push(nombre);
      } else if (nombreLower.includes('ingreso') || nombreLower.includes('alma')) {
        grupos.ingresos.push(nombre);
      } else if (nombreLower.includes('porcentaje') || nombreLower.includes('%') || 
                 nombreLower.includes('tasa') || nombreLower.includes('ratio')) {
        grupos.porcentajes.push(nombre);
      } else {
        grupos.otros.push(nombre);
      }
    });
    
    console.log('\nüìã GRUPOS IDENTIFICADOS:');
    console.log('='.repeat(40));
    
    Object.keys(grupos).forEach(grupo => {
      if (grupos[grupo].length > 0) {
        console.log(`\nüè∑Ô∏è ${grupo.toUpperCase()} (${grupos[grupo].length} m√©tricas):`);
        grupos[grupo].forEach((nombre, index) => {
          const valor = metricas[nombre];
          console.log(`  ${index + 1}. ${nombre}: ${valor}`);
        });
      }
    });
    
    // Proponer organizaci√≥n en 2 filas de 4 m√©tricas
    console.log('\nüéØ ORGANIZACI√ìN SUGERIDA:');
    console.log('='.repeat(50));
    
    // Seleccionar las 8 m√©tricas m√°s importantes para las 2 filas
    const metricasPrioritarias = [];
    
    // Prioridad 1: M√©tricas de actividad (m√°s importantes)
    metricasPrioritarias.push(...grupos.actividad.slice(0, 4));
    
    // Prioridad 2: M√©tricas de l√≠deres
    if (metricasPrioritarias.length < 4) {
      metricasPrioritarias.push(...grupos.lideres.slice(0, 4 - metricasPrioritarias.length));
    }
    
    // Prioridad 3: M√©tricas de c√©lulas
    if (metricasPrioritarias.length < 4) {
      metricasPrioritarias.push(...grupos.celulas.slice(0, 4 - metricasPrioritarias.length));
    }
    
    // Prioridad 4: M√©tricas de ingresos
    if (metricasPrioritarias.length < 4) {
      metricasPrioritarias.push(...grupos.ingresos.slice(0, 4 - metricasPrioritarias.length));
    }
    
    // Prioridad 5: Otras m√©tricas
    if (metricasPrioritarias.length < 4) {
      metricasPrioritarias.push(...grupos.otros.slice(0, 4 - metricasPrioritarias.length));
    }
    
    // Segunda fila: m√©tricas restantes
    const metricasRestantes = metricasArray.filter(nombre => !metricasPrioritarias.includes(nombre));
    const segundaFila = metricasRestantes.slice(0, 4);
    
    console.log('üèÜ FILA 1 - M√©tricas Principales (4 m√©tricas):');
    metricasPrioritarias.forEach((nombre, index) => {
      const valor = metricas[nombre] || 0;
      console.log(`  ${index + 1}. ${nombre}: ${valor}`);
    });
    
    if (segundaFila.length > 0) {
      console.log('\nüìä FILA 2 - M√©tricas Secundarias (4 m√©tricas):');
      segundaFila.forEach((nombre, index) => {
        const valor = metricas[nombre] || 0;
        console.log(`  ${index + 1}. ${nombre}: ${valor}`);
      });
    }
    
    // M√©tricas sobrantes
    const metricasSobrantes = metricasRestantes.slice(4);
    if (metricasSobrantes.length > 0) {
      console.log('\nüîÑ M√âTRICAS ADICIONALES (no incluidas en las 2 filas):');
      metricasSobrantes.forEach((nombre, index) => {
        const valor = metricas[nombre] || 0;
        console.log(`  ${index + 1}. ${nombre}: ${valor}`);
      });
    }
    
    // Generar estructura HTML din√°mica
    console.log('\nüíª ESTRUCTURA HTML GENERADA:');
    console.log('='.repeat(50));
    
    let htmlFila1 = `<!-- FILA 1: M√©tricas Principales -->
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">`;
    
    metricasPrioritarias.forEach((nombre, index) => {
      const valor = metricas[nombre] || 0;
      const color = ['blue', 'green', 'yellow', 'red'][index % 4];
      const icono = ['fa-users', 'fa-check-circle', 'fa-exclamation-triangle', 'fa-chart-line'][index % 4];
      
      htmlFila1 += `
    <div class="stat-card">
        <div class="flex items-center justify-between">
            <div>
                <p class="text-gray-500 text-sm">${nombre}</p>
                <p class="text-3xl font-bold text-${color}-600">${valor}</p>
            </div>
            <i class="fas ${icono} text-${color}-500 text-3xl"></i>
        </div>
    </div>`;
    });
    
    htmlFila1 += `\n</div>`;
    
    let htmlFila2 = '';
    if (segundaFila.length > 0) {
      htmlFila2 = `\n<!-- FILA 2: M√©tricas Secundarias -->
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">`;
      
      segundaFila.forEach((nombre, index) => {
        const valor = metricas[nombre] || 0;
        const color = ['purple', 'indigo', 'teal', 'pink'][index % 4];
        const icono = ['fa-chart-bar', 'fa-percentage', 'fa-home', 'fa-user-tie'][index % 4];
        
        htmlFila2 += `
    <div class="stat-card">
        <div class="flex items-center justify-between">
            <div>
                <p class="text-gray-500 text-sm">${nombre}</p>
                <p class="text-3xl font-bold text-${color}-600">${valor}</p>
            </div>
            <i class="fas ${icono} text-${color}-500 text-3xl"></i>
        </div>
    </div>`;
      });
      
      htmlFila2 += `\n</div>`;
    }
    
    console.log(htmlFila1 + htmlFila2);
    
    resultados.organizacion_sugerida = {
      fila1: metricasPrioritarias,
      fila2: segundaFila,
      metricas_sobrantes: metricasSobrantes,
      total_metricas: contador,
      grupos: grupos
    };
    
    console.log('\n‚úÖ AN√ÅLISIS COMPLETADO');
    console.log(`üìä Total de m√©tricas en la hoja: ${contador}`);
    console.log(`üèÜ M√©tricas en Fila 1: ${metricasPrioritarias.length}`);
    console.log(`üìä M√©tricas en Fila 2: ${segundaFila.length}`);
    console.log(`üîÑ M√©tricas adicionales: ${metricasSobrantes.length}`);
    
  } catch (error) {
    console.error('‚ùå Error analizando la hoja:', error);
    resultados.exito = false;
  }
  
  return resultados;
}

/**
 * Prueba la funcionalidad completa de las 8 m√©tricas en 2 filas
 */
function probar8MetricasDashboard() {
  console.log('üß™ PRUEBA: 8 M√©tricas en Dashboard (2 filas)');
  console.log('='.repeat(60));
  
  const resultados = {
    timestamp: new Date().toISOString(),
    tests: {},
    exito: true
  };
  
  try {
    // Limpiar cach√© para forzar recarga
    clearCache();
    
    // Obtener estad√≠sticas
    const stats = getEstadisticasRapidas();
    
    if (stats.success && stats.data) {
      const fila1 = stats.data.fila1;
      const fila2 = stats.data.fila2;
      const calculadas = stats.data.calculadas;
      
      console.log('üìä Verificando estructura de datos:');
      console.log('  fila1:', Object.keys(fila1));
      console.log('  fila2:', Object.keys(fila2));
      console.log('  calculadas:', Object.keys(calculadas));
      
      // Test 1: Verificar que fila1 tiene 4 m√©tricas
      const fila1Correcta = Object.keys(fila1).length === 4;
      console.log(`\n‚úÖ Test 1 - Fila 1 tiene 4 m√©tricas: ${fila1Correcta ? 'PASS' : 'FAIL'}`);
      console.log('  M√©tricas fila1:', Object.keys(fila1));
      resultados.tests.fila1_4_metricas = fila1Correcta;
      
      if (!fila1Correcta) {
        resultados.exito = false;
      }
      
      // Test 2: Verificar que fila2 tiene 4 m√©tricas
      const fila2Correcta = Object.keys(fila2).length === 4;
      console.log(`\n‚úÖ Test 2 - Fila 2 tiene 4 m√©tricas: ${fila2Correcta ? 'PASS' : 'FAIL'}`);
      console.log('  M√©tricas fila2:', Object.keys(fila2));
      resultados.tests.fila2_4_metricas = fila2Correcta;
      
      if (!fila2Correcta) {
        resultados.exito = false;
      }
      
      // Test 3: Verificar m√©tricas espec√≠ficas de fila1
      const metricasFila1Esperadas = [
        'activos_recibiendo_celula',
        'lideres_hibernando', 
        'total_lideres',
        'total_asistentencia_celulas'
      ];
      
      const fila1TieneMetricasEsperadas = metricasFila1Esperadas.every(metrica => 
        fila1.hasOwnProperty(metrica)
      );
      
      console.log(`\n‚úÖ Test 3 - Fila 1 tiene m√©tricas esperadas: ${fila1TieneMetricasEsperadas ? 'PASS' : 'FAIL'}`);
      resultados.tests.fila1_metricas_esperadas = fila1TieneMetricasEsperadas;
      
      if (!fila1TieneMetricasEsperadas) {
        resultados.exito = false;
      }
      
      // Test 4: Verificar m√©tricas espec√≠ficas de fila2
      const metricasFila2Esperadas = [
        'alerta_2_3_semanas',
        'critico_mas_1_mes',
        'total_celulas',
        'total_ingresos'
      ];
      
      const fila2TieneMetricasEsperadas = metricasFila2Esperadas.every(metrica => 
        fila2.hasOwnProperty(metrica)
      );
      
      console.log(`\n‚úÖ Test 4 - Fila 2 tiene m√©tricas esperadas: ${fila2TieneMetricasEsperadas ? 'PASS' : 'FAIL'}`);
      resultados.tests.fila2_metricas_esperadas = fila2TieneMetricasEsperadas;
      
      if (!fila2TieneMetricasEsperadas) {
        resultados.exito = false;
      }
      
      // Test 5: Verificar que los valores no son todos cero
      const valoresFila1 = Object.values(fila1);
      const valoresFila2 = Object.values(fila2);
      const todosValores = [...valoresFila1, ...valoresFila2];
      
      const hayValoresNoCero = todosValores.some(valor => 
        typeof valor === 'number' && valor > 0
      );
      
      console.log(`\n‚úÖ Test 5 - Hay valores no cero: ${hayValoresNoCero ? 'PASS' : 'FAIL'}`);
      console.log('  Valores fila1:', valoresFila1);
      console.log('  Valores fila2:', valoresFila2);
      resultados.tests.hay_valores_no_cero = hayValoresNoCero;
      
      if (!hayValoresNoCero) {
        console.log('‚ö†Ô∏è Todos los valores son cero - verificar hoja _ResumenDashboard');
        resultados.exito = false;
      }
      
      // Test 6: Verificar c√°lculos de porcentajes
      const porcentajesCorrectos = 
        calculadas.hasOwnProperty('porcentaje_activos') &&
        calculadas.hasOwnProperty('porcentaje_alerta') &&
        calculadas.hasOwnProperty('porcentaje_critico');
      
      console.log(`\n‚úÖ Test 6 - Porcentajes calculados: ${porcentajesCorrectos ? 'PASS' : 'FAIL'}`);
      console.log('  Porcentajes:', calculadas);
      resultados.tests.porcentajes_calculados = porcentajesCorrectos;
      
      if (!porcentajesCorrectos) {
        resultados.exito = false;
      }
      
      // Test 7: Verificar valores espec√≠ficos esperados
      console.log('\nüìä VALORES ESPEC√çFICOS:');
      console.log(`  Activos recibiendo celula: ${fila1.activos_recibiendo_celula}`);
      console.log(`  L√≠deres hibernando: ${fila1.lideres_hibernando}`);
      console.log(`  Total L√≠deres: ${fila1.total_lideres}`);
      console.log(`  Total Asistencia C√©lulas: ${fila1.total_asistentencia_celulas}`);
      console.log(`  2-3 semanas sin celula: ${fila2.alerta_2_3_semanas}`);
      console.log(`  +1 mes sin celula: ${fila2.critico_mas_1_mes}`);
      console.log(`  Total C√©lulas: ${fila2.total_celulas}`);
      console.log(`  Total Ingresos: ${fila2.total_ingresos}`);
      
    } else {
      console.error('‚ùå Error obteniendo estad√≠sticas');
      resultados.tests.estadisticas_ok = false;
      resultados.exito = false;
    }
    
  } catch (error) {
    console.error('‚ùå Error cr√≠tico en test:', error);
    resultados.exito = false;
  }
  
  // Resumen
  console.log('\n' + '='.repeat(60));
  console.log('üìä RESUMEN DE TESTS');
  console.log('='.repeat(60));
  
  Object.keys(resultados.tests).forEach(test => {
    const resultado = resultados.tests[test];
    const icono = resultado ? '‚úÖ' : '‚ùå';
    console.log(`${icono} ${test}: ${resultado ? 'PASS' : 'FAIL'}`);
  });
  
  if (resultados.exito) {
    console.log('\nüéâ ¬°TODAS LAS 8 M√âTRICAS FUNCIONAN CORRECTAMENTE!');
    console.log('‚úÖ 2 filas de 4 m√©tricas cada una');
    console.log('‚úÖ Estructura de datos correcta');
    console.log('‚úÖ Valores no son todos cero');
    console.log('‚úÖ Porcentajes calculados correctamente');
    console.log('üîÑ Recarga el dashboard para ver las 8 m√©tricas organizadas');
  } else {
    console.log('\n‚ö†Ô∏è ALGUNOS TESTS FALLARON');
    console.log('üí° Revisar logs anteriores para detalles');
    console.log('üí° Verificar que la hoja _ResumenDashboard tenga datos');
  }
  
  return resultados;
}

console.log('üß™ SistemaTestsRobusto cargado - Sistema consolidado de pruebas disponible');
